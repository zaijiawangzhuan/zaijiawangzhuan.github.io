<!DOCTYPE html><html><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><meta name="randerer" content="webkit"><meta http-equiv="Cache-Control" content="no-siteapp"><meta http-equiv="Cache-Control" content="no-transform"><title>Android知识集合 | C Blog</title><link rel="stylesheet" href="/css/normailze.css"><link rel="stylesheet" href="/css/style.css"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico"></head><body><!--[if ltg IE 9]><div>是时候换个现代浏览器了，点击更换<a href="http://browsehappy.com/"></a></div><!--<![endif]--><header><!--include nav--></header><section class="content"><article class="content__post"><h1 class="post__title">Android知识集合</h1><div class="post__date">2017-06-20</div><section><ul>
<li>content<br>{:toc}</li>
</ul>
<h3 id="Activity的几种LaunchMode及使用场景"><a href="#Activity的几种LaunchMode及使用场景" class="headerlink" title="Activity的几种LaunchMode及使用场景"></a>Activity的几种LaunchMode及使用场景</h3><h4 id="standard-模式"><a href="#standard-模式" class="headerlink" title="standard 模式"></a>standard 模式</h4><p> 这是默认模式，每次激活Activity时都会创建Activity实例，并放入任务栈中。使用场景：大多数Activity。</p>
<h4 id="singleTop-模式"><a href="#singleTop-模式" class="headerlink" title="singleTop 模式"></a>singleTop 模式</h4><p>如果在任务栈顶正好存在改Activity ，就重用该Activity( 会调用实例的 onNewIntent() ), 使用场景 如通知栏 点击重复进入Activity</p>
<h4 id="singleTask-模式"><a href="#singleTask-模式" class="headerlink" title="singleTask 模式"></a>singleTask 模式</h4><p>如果任务栈堆 有该Activity 就重用该实例，重用时 会让该实例回到栈顶 ，之前在它上面的实例会被移除  使用场景如 主界面  需要清空上面所有activity的情况</p>
<h4 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h4><p>单一实例模式， 整个手机操作系统只有一个实例 使用场景如: 呼叫来电</p>
<h3 id="如何理解Activity，View，Window三者之间的关系？"><a href="#如何理解Activity，View，Window三者之间的关系？" class="headerlink" title="如何理解Activity，View，Window三者之间的关系？"></a>如何理解Activity，View，Window三者之间的关系？</h3><blockquote>
<p>Activity 是android 应用组件，提供一个屏幕 共用户交互 。每个activity会给于一个窗口 在上面可以绘制view</p>
</blockquote>
<p>1: Activity构造的时候会初始化一个Window，准确的说是PhoneWindow。</p>
<p>2: 这个PhoneWindow有一个“ViewRoot”，这个“ViewRoot”是一个View或者说ViewGroup，是最初始的根视图。</p>
<p>3：“ViewRoot”通过addView方法来一个个的添加View。比如TextView，Button等</p>
<p>4：这些View的事件监听，是由WindowManagerService来接受消息，并且回调Activity函数。比如onClickListener，onKeyDown等。</p>
<p>Activity 层级关系：每个Activity包含一个PhoneWindow对象，PhoneWindow设置DecorView为应用窗口的根视图。在里面就是熟悉的TitleView和ContentView,没错，平时使用的setContentView()就是设置的ContentView</p>
<h3 id="启动service的两种方法和区别"><a href="#启动service的两种方法和区别" class="headerlink" title="启动service的两种方法和区别"></a>启动service的两种方法和区别</h3><p>startService 和 bindService， startService 启动后即与调用者没关系了 关闭需调用stopService, bindService与调用者绑定在一起可以进行通信 关闭了调用者服务也退出了</p>
<h3 id="Service-是否在-main-thread-中执行-service-里面是否能执行耗时的操作"><a href="#Service-是否在-main-thread-中执行-service-里面是否能执行耗时的操作" class="headerlink" title="Service 是否在 main thread 中执行, service 里面是否能执行耗时的操作"></a>Service 是否在 main thread 中执行, service 里面是否能执行耗时的操作</h3><h3 id="RecyleView-和-ListView"><a href="#RecyleView-和-ListView" class="headerlink" title="RecyleView 和 ListView"></a>RecyleView 和 ListView</h3><h3 id="Android-TouchEvent事件分发机制"><a href="#Android-TouchEvent事件分发机制" class="headerlink" title="Android TouchEvent事件分发机制"></a>Android TouchEvent事件分发机制</h3><table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>dispatchTouchEvent()</td>
<td>用来分派事件。其中调用了onInterceptTouchEvent()和onTouchEvent()，一般不重写该方法</td>
</tr>
<tr>
<td>onInterceptTouchEvent()</td>
<td>用来拦截事件。ViewGroup类中的源码实现就是{return false;}表示不拦截该事件，事件将向下传递（传递给其子View）；若手动重写该方法，使其返回true则表示拦截，事件将终止向下传递，事件由当前ViewGroup类来处理，就是调用该类的onTouchEvent()方法</td>
</tr>
<tr>
<td>onTouchEvent（）</td>
<td>用来处理事件。返回true则表示该View能处理该事件，事件将终止向上传递（传递给其父View）；返回false表示不能处理，则把事件传递给其父View的onTouchEvent()方法来处理</td>
</tr>
</tbody>
</table>
<p><a href="http://blog.csdn.net/morgan_xww/article/details/9372285" target="_blank" rel="noopener">TouchEvent事件分发机制</a></p>
<h3 id="Android-View的绘制流程"><a href="#Android-View的绘制流程" class="headerlink" title="Android View的绘制流程"></a>Android View的绘制流程</h3><p>可以经过三个过程 measure、layout、draw 过程<br><a href="http://www.codekk.com/blogs/detail/54cfab086c4761e5001b253f" target="_blank" rel="noopener">参考链接</a></p>
<h3 id="Android-跨进程通讯的几种方式"><a href="#Android-跨进程通讯的几种方式" class="headerlink" title="Android 跨进程通讯的几种方式"></a>Android 跨进程通讯的几种方式</h3><p>1.通过Intent访问其他应用程序Activity</p>
<ol start="2">
<li>Content Provider  访问系统相册</li>
<li>广播</li>
<li>AIDL 服务</li>
</ol>
<h3 id="Handler的原理"><a href="#Handler的原理" class="headerlink" title="Handler的原理"></a>Handler的原理</h3><ul>
<li>使用场景 handler 一般用于延时操作或接收子线程发送的数据， 用此数据配合主线程更新UI。  </li>
<li>原理: Looper负责创建MessageQueue 然后无限循环的从MessageQueue中读取 handler发过来的消息</li>
</ul>
<p><a href="http://blog.csdn.net/lmj623565791/article/details/38377229" target="_blank" rel="noopener">参考链接</a></p>
<h3 id="Binder机制原理"><a href="#Binder机制原理" class="headerlink" title="Binder机制原理"></a>Binder机制原理</h3><p><a href="http://blog.csdn.net/boyupeng/article/details/47011383" target="_blank" rel="noopener">参考链接</a></p>
<h3 id="AsyncTask-相关"><a href="#AsyncTask-相关" class="headerlink" title="AsyncTask 相关"></a>AsyncTask 相关</h3><h5 id="AsynTask内部实行-使用场景"><a href="#AsynTask内部实行-使用场景" class="headerlink" title="AsynTask内部实行 使用场景"></a>AsynTask内部实行 使用场景</h5><p>内部是通过Handler 机制来完成，Android提供执行框架来提供线程池执行相关任务，因为线程池的大小问题 只能执行耗时短的任务如http请求对于大规模下载不适用AysncTask会造成线程池堵塞 发现AysncTask执行不了</p>
<h5 id="1-AsynTask为什么要设计为只能够一次任务？"><a href="#1-AsynTask为什么要设计为只能够一次任务？" class="headerlink" title="1.AsynTask为什么要设计为只能够一次任务？"></a>1.AsynTask为什么要设计为只能够一次任务？</h5><p> 最核心的还是线程安全问题，多个子线程同时运行，会产生状态不一致的问题。所以要务必保证只能够执行一次</p>
<h5 id="2-AsynTask造成的内存泄露的问题怎么解决"><a href="#2-AsynTask造成的内存泄露的问题怎么解决" class="headerlink" title="2.AsynTask造成的内存泄露的问题怎么解决"></a>2.AsynTask造成的内存泄露的问题怎么解决</h5><p> 比如非静态内部类AsynTask会隐式地持有外部类的引用，如果其生命周期大于外部activity的生命周期，就会出现内存泄漏注意要复写AsynTask的onCancel方法，把里面的socket，file等，该关掉的要及时关掉在 Activity 的onDestory()方法中调用Asyntask.cancal方法Asyntask内部使用弱引用的方式来持有Activity</p>
<h5 id="3-若Activity已经销毁，此时AsynTask执行完并且返回结果，会报异常吗"><a href="#3-若Activity已经销毁，此时AsynTask执行完并且返回结果，会报异常吗" class="headerlink" title="3. 若Activity已经销毁，此时AsynTask执行完并且返回结果，会报异常吗?"></a>3. 若Activity已经销毁，此时AsynTask执行完并且返回结果，会报异常吗?</h5><p> 当一个App旋转时，整个Activity会被销毁和重建。当Activity重启时，AsyncTask中对该Activity的引用是无效的，因此onPostExecute()就不会起作用，若AsynTask正在执行，折会报 view not attached to window manager 异常同样也是生命周期的问题，在 Activity 的onDestory()方法中调用Asyntask.cancal方法，让二者的生命周期同步</p>
<h5 id="4-Activity销毁但Task如果没有销毁掉，当Activity重启时这个AsyncTask该如何解决？"><a href="#4-Activity销毁但Task如果没有销毁掉，当Activity重启时这个AsyncTask该如何解决？" class="headerlink" title="4. Activity销毁但Task如果没有销毁掉，当Activity重启时这个AsyncTask该如何解决？"></a>4. Activity销毁但Task如果没有销毁掉，当Activity重启时这个AsyncTask该如何解决？</h5><p>还是屏幕旋转这个例子，在重建Activity的时候，会回掉Activity.onRetainNonConfigurationInstance()重新传递一个新的对象给AsyncTask，完成引用的更新</p>
<h3 id="ANR"><a href="#ANR" class="headerlink" title="ANR"></a>ANR</h3><p>应用程序在一段时间不够灵敏，系统就会显示一个对话框</p>
<h5 id="产生的原因"><a href="#产生的原因" class="headerlink" title="产生的原因:"></a>产生的原因:</h5><ol>
<li>来自AMS的回调消息 当AMS对应用组件的生命周期进行回调的时间超过自定义的响应时间就会包ANR，回调函数及超过时间如下:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Activity: onCreate(), onResume(), onDestroy(), </span><br><span class="line">onKeyDown(), onClick()等，超时时间5s</span><br><span class="line"></span><br><span class="line">Application: onCreate(), onTerminate()等，超时时间5s</span><br><span class="line"></span><br><span class="line">Service: onCreate(), onStart(), onDestroy()等，超时时间20s</span><br><span class="line"></span><br><span class="line">BroadcastReceiver：onReceiver()，前台APP广播超时时间是10s，后台App是60s</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>App 其他操作运行在UI线程的</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AsyncTask: onPreExecute(), onProgressUpdate(), onPostExecute(), onCancel()等，超时5s</span><br><span class="line"></span><br><span class="line">Mainthread handler: handleMessage(), post*(runnable r)等，超时5s</span><br></pre></td></tr></table></figure>
<h5 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h5><ol>
<li>耗时操作放入子线程中</li>
<li>使用handler 来处理UI 线程和其他线程的交互</li>
</ol>
<p><a href="http://www.jianshu.com/p/124f3b75e164" target="_blank" rel="noopener">参考链接</a></p>
<h3 id="Android内存泄漏"><a href="#Android内存泄漏" class="headerlink" title="Android内存泄漏"></a>Android内存泄漏</h3><p>当一个对象已经不需要使用了，本该回收的时候，另一个正在使用的对象持有它的引用导致它不能被回收 这不能回收的对象就在推内存中，就产生了内存泄漏  当内存超出系统分配的内存限额 引用就会Crash</p>
<ul>
<li>常见内存泄漏汇总</li>
</ul>
<ol>
<li>单例造成的内存泄漏</li>
<li>非静态内部类 创建静态实例造成的内存泄漏</li>
<li>Handler造成的内存泄漏</li>
<li>线程造成的泄漏</li>
<li>资源未关闭造成的内存泄漏</li>
</ol>
<p><a href="https://juejin.im/entry/56d64b9e816dfa005943a55c" target="_blank" rel="noopener">参考链接</a></p>
<h3 id="布局优化"><a href="#布局优化" class="headerlink" title="布局优化"></a>布局优化</h3><p>1.合理选择控件容器， 尽量减少层次 相同层次使用LinearLayout</p>
<ol start="2">
<li>去掉window的默认背景</li>
<li>去掉其他不别要的背景<br>4.ViewStub 高效占位符， 对于比较复杂的需要显示隐藏的布局 可以通过viewStub 控制</li>
<li>Merge</li>
</ol>
<h3 id="图片优化"><a href="#图片优化" class="headerlink" title="图片优化"></a>图片优化</h3><p>一些优化方案  非重点<br><a href="http://www.jianshu.com/p/5bb8c01e2bc7" target="_blank" rel="noopener">参考链接</a></p>
<h3 id="图片缓存"><a href="#图片缓存" class="headerlink" title="图片缓存"></a>图片缓存</h3><p>内存缓存 LruCache + 磁盘缓存 DiskLruCache + 网络请求 组成三级缓存</p>
<h3 id="热修复原理"><a href="#热修复原理" class="headerlink" title="热修复原理"></a>热修复原理</h3><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>MVC MVP MVVM</p>
<h3 id="设计架构"><a href="#设计架构" class="headerlink" title="设计架构"></a>设计架构</h3><p><a href="https://juejin.im/entry/56ebb4ad5bbb50004c440972" target="_blank" rel="noopener">参考链接</a></p>
<h3 id="RXJAVA"><a href="#RXJAVA" class="headerlink" title="RXJAVA"></a>RXJAVA</h3></section></article></section><section class="comment"><div class="ds-thread" data-thread-key="2017/06/20/2017-06-20-Android知识集合/" data-title="Android知识集合" data-url="http://zaijiangwangzhuan.com/2017/06/20/2017-06-20-Android知识集合/"></div><script>var duoshuoQuery = {short_name:'chordblog'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
})()</script></section><footer></footer><!--include copyright--></body></html>