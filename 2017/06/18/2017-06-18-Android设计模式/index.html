<!DOCTYPE html><html><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><meta name="randerer" content="webkit"><meta http-equiv="Cache-Control" content="no-siteapp"><meta http-equiv="Cache-Control" content="no-transform"><title>Android设计模式 | 在家网赚</title><link rel="stylesheet" href="/css/normailze.css"><link rel="stylesheet" href="/css/style.css"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico"></head><body><!--[if ltg IE 9]><div>是时候换个现代浏览器了，点击更换<a href="http://browsehappy.com/"></a></div><!--<![endif]--><header><!--include nav--></header><section class="content"><article class="content__post"><h1 class="post__title">Android设计模式</h1><div class="post__date">2017-06-18</div><section><ul>
<li>content<br>{:toc}</li>
</ul>
<p>按照 设计模式定义–&gt; 通常在什么情况使用 –&gt; 示例</p>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><blockquote>
<p>（1）基本定义：设计模式（Design pattern）是一套被反复使用的代码设计经验的总结。使用设计模式的目的是为了可重用代码、让代码更容易被他人理解。设计模式是是软件工程的基石脉络，如大厦的结构一样。</p>
</blockquote>
<blockquote>
<p>（2）Design pattern的四大要素：模式名称（Name），问题（Question），解决方案（Solution），效果（Efftive）。</p>
</blockquote>
<blockquote>
<p>（3）OO（面向对象）的六大原则：单一职责原则，开闭原则，里氏替换原则，依赖倒置原则，接口隔离原则，迪米特原则。</p>
</blockquote>
<blockquote>
<p>单一职责原则：一个类中应该是一组相关性很高的函数，数据的封装。两个完全不一样的功能就不应该放在一个类中。</p>
</blockquote>
<blockquote>
<p>开闭原则：对修改封闭，对扩展放开。</p>
</blockquote>
<blockquote>
<p>里氏替换原则：抽象和继承；所有引用基类的地方必须能透明的使用其子类的对象。</p>
</blockquote>
<blockquote>
<p>依赖倒置原则：抽象不应该依赖细节，细节应该依赖抽象。</p>
</blockquote>
<blockquote>
<p>接口隔离原则：将大接口改成多个小接口。</p>
</blockquote>
<blockquote>
<p>迪米特原则：也称为最少知识原则，一个对象应该对另一个对象有最少的了解。</p>
</blockquote>
<h3 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h3><p>设计模式分为三种类型：</p>
<blockquote>
<p>（1）创建型模式5种：单例模式，抽象工厂模式，工厂模式，原型模式，建造者模式。<br>（口诀：单原建造者，东西二厂）</p>
</blockquote>
<blockquote>
<p>（2）结构型模式7种：适配器模式，桥接模式，装饰模式，组合模式，外观模式，享元模式，代理模式。<br>（口诀：一器一桥一元一代理；装饰组合外观）</p>
</blockquote>
<blockquote>
<p>（3）行为型模式11种：观察者模式，中介者模式，访问者模式，解释器模式，迭代器模式，备忘录模式，责任链模式，状态模式，策略模式，命令模式，模板模式。<br>（口诀：三者两器、一录一链一模板，状态策略命令）</p>
</blockquote>
<h4 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1. 单例模式"></a>1. 单例模式</h4><blockquote>
<p>确保一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。</p>
</blockquote>
<h4 id="App-只需要一个类-实例，或者类的初始化操作比较耗费资源，-不如-网络加载和-图片加载"><a href="#App-只需要一个类-实例，或者类的初始化操作比较耗费资源，-不如-网络加载和-图片加载" class="headerlink" title="App 只需要一个类 实例，或者类的初始化操作比较耗费资源， 不如 网络加载和 图片加载"></a>App 只需要一个类 实例，或者类的初始化操作比较耗费资源， 不如 网络加载和 图片加载</h4><ul>
<li>Android中的系统级服务都是通过容器的单例模式实现方式，以单例形式存在，减少了资源消耗 如 LayoutInflater Service， ActivityManager InputMethodManager AccessibilityManager 中 getInstance 都是单例</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static volatile Singleton instance = null;</span><br><span class="line"></span><br><span class="line">    private Singleton()&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                if (instance == null) &#123;</span><br><span class="line">                    instance = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-Builder-建造者-模式"><a href="#2-Builder-建造者-模式" class="headerlink" title="2.Builder(建造者)模式"></a>2.Builder(建造者)模式</h3><blockquote>
<p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</p>
</blockquote>
<h4 id="一个类的构造需要很多参数，而且这些参数都不是必须的，就比较适合Builder"><a href="#一个类的构造需要很多参数，而且这些参数都不是必须的，就比较适合Builder" class="headerlink" title="一个类的构造需要很多参数，而且这些参数都不是必须的，就比较适合Builder"></a>一个类的构造需要很多参数，而且这些参数都不是必须的，就比较适合Builder</h4><ul>
<li><p>Android中最常用的就是Dialog的构建，Notification的构建也是标准的建造者模式。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private double height;</span><br><span class="line">    private double weight;</span><br><span class="line"></span><br><span class="line">    privatePerson(Builder builder) &#123;</span><br><span class="line">        this.name=builder.name;</span><br><span class="line">        this.age=builder.age;</span><br><span class="line">        this.height=builder.height;</span><br><span class="line">        this.weight=builder.weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Get @Set</span><br><span class="line">    static class Builder&#123;</span><br><span class="line">        private String name;</span><br><span class="line">        private int age;</span><br><span class="line">        private double height;</span><br><span class="line">        private double weight;</span><br><span class="line">        public Builder name(String name)&#123;</span><br><span class="line">            this.name=name;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">        public Builder age(int age)&#123;</span><br><span class="line">            this.age=age;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">        public Builder height(double height)&#123;</span><br><span class="line">            this.height=height;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Builder weight(double weight)&#123;</span><br><span class="line">            this.weight=weight;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Person build()&#123;</span><br><span class="line">            return new Person(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样创建Person 类就可以这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> Person.Builder builder=new Person.Builder();</span><br><span class="line">Person person=builder</span><br><span class="line">		.name(&quot;张三&quot;)</span><br><span class="line">		.age(18)</span><br><span class="line">		.height(178.5)</span><br><span class="line">		.weight(67.4)</span><br><span class="line">		.build();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-工厂方法模式"><a href="#3-工厂方法模式" class="headerlink" title="3. 工厂方法模式"></a>3. 工厂方法模式</h3><blockquote>
<p>定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类。</p>
</blockquote>
<p>示例：BitmapFactory位图工厂，专门用来将指定的图片转换为指定的位图Bitmap。</p>
<h3 id="4-抽象工厂模式"><a href="#4-抽象工厂模式" class="headerlink" title="4. 抽象工厂模式"></a>4. 抽象工厂模式</h3><blockquote>
<p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p>
</blockquote>
<p>Android底层对MediaPlayer的创建。<br>MediaPlayerFactory是Android底层为了创建不同的MediaPlayer所定义的一个类。</p>
<h3 id="5-原型模式"><a href="#5-原型模式" class="headerlink" title="5. 原型模式"></a>5. 原型模式</h3><blockquote>
<p>用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象</p>
</blockquote>
<p>比如我们需要一张Bitmap的几种不同格式：ARGB_8888、RGB_565、ARGB_4444、ALAPHA_8等。那我们就可以先创建一个ARGB_8888的Bitmap作为原型，在它的基础上，通过调用Bitmap.copy(Config)来创建出其它几种格式的Bitmap。另外一个例子就是Java中所有对象都有的一个名字叫clone的方法，已经原型模式的代名词了。在系统中要创建大量的对象，这些对象之间具有几乎完全相同的功能，只是在细节上有一点儿差别。</p>
<h3 id="6-适配器模式"><a href="#6-适配器模式" class="headerlink" title="6. 适配器模式"></a>6. 适配器模式</h3><blockquote>
<p>将一个类的接口转换成客户希望的另外一个接口</p>
</blockquote>
<p>不同的数据提供者使用一个适配器来向一个相同的客户提供服务。ListView或GridView的Adapter。</p>
<h3 id="7-组合模式"><a href="#7-组合模式" class="headerlink" title="7. 组合模式"></a>7. 组合模式</h3><blockquote>
<p>将对象组合成树形结构以表示“部分-整体”的层次结构。</p>
</blockquote>
<p>示例：View和ViewGroup的组合</p>
<h3 id="8-桥接模式"><a href="#8-桥接模式" class="headerlink" title="8.桥接模式"></a>8.桥接模式</h3><blockquote>
<p>将抽象部分与它的实现部分分离，使它们都可以独立地变化</p>
</blockquote>
<p>示例：Window和WindowManager之间的关系。<br>在FrameWork中Window和PhoneWindow构成窗口的抽象部分，其中Window类为该抽象部分的抽象接口，PhoneWindow为抽象部分具体的实现及扩展。而WindowManager则为实现部分的基类，WindowManagerImpl则为实现部分具体的逻辑实现。</p>
<h3 id="9-装饰模式"><a href="#9-装饰模式" class="headerlink" title="9. 装饰模式"></a>9. 装饰模式</h3><blockquote>
<p>动态地给一个对象添加一些额外的职责。就扩展功能而言， 它比生成子类方式更为灵活。</p>
</blockquote>
<p>示例：Activity继承自ContextThemeWrapper，ContextThemeWrapper继承自ContextWrapper，ContextWrapper才是继承自Context。ContextWrapper就是我们找的装饰者。</p>
<h3 id="10-外观模式"><a href="#10-外观模式" class="headerlink" title="10.外观模式"></a>10.外观模式</h3><blockquote>
<p>为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，统一编程接口。</p>
</blockquote>
<p>示例：ContextImpl</p>
<h3 id="11-享元模式"><a href="#11-享元模式" class="headerlink" title="11.享元模式"></a>11.享元模式</h3><blockquote>
<p>运用共享技术有效地支持大量细粒度的对象</p>
</blockquote>
<p>示例：Message.obtainMessage通过重用Message对象来避免大量的Message对象被频繁的创建和销毁。</p>
<h3 id="12-代理模式"><a href="#12-代理模式" class="headerlink" title="12. 代理模式"></a>12. 代理模式</h3><blockquote>
<p>为其他对象提供一个代理以控制对这个对象的访问。</p>
</blockquote>
<p>示例：所有的AIDL都一个代理模式的例子。假设一个Activity A去绑定一个Service S，那么A调用S中的每一个方法其实都是通过系统的Binder机制的中转，然后调用S中的对应方法来做到的。Binder机制就起到了代理的作用。</p>
<h3 id="13-观察者模式"><a href="#13-观察者模式" class="headerlink" title="13. 观察者模式"></a>13. 观察者模式</h3><blockquote>
<p>一个对象发生改变时，所有信赖于它的对象自动做相应改变。</p>
</blockquote>
<p>示例：我们可以通过BaseAdapter.registerDataSetObserver和BaseAdapter.unregisterDataSetObserver两方法来向BaseAdater注册、注销一个DataSetObserver。这个过程中，DataSetObserver就是一个观察者，它一旦发现BaseAdapter内部数据有变量，就会通过回调方法DataSetObserver.onChanged和DataSetObserver.onInvalidated来通知DataSetObserver的实现类。事件通知也是观察者模式。</p>
<h3 id="14-中介者模式"><a href="#14-中介者模式" class="headerlink" title="14. 中介者模式"></a>14. 中介者模式</h3><blockquote>
<p>用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。<br>示例：Binder机制。</p>
</blockquote>
<h3 id="15-访问者模式"><a href="#15-访问者模式" class="headerlink" title="15.访问者模式:"></a>15.访问者模式:</h3><blockquote>
<p>表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p>
</blockquote>
<p>示例：编译时注解中的ElementVisitor中定义多个Visit接口，每个接口处理一种数据类型，这就是典型的访问者模式，访问者模式正好解决了数据结构和数据操作分离的问题，避免某些操作污染了数据对象类。</p>
<h3 id="16-解释器模式："><a href="#16-解释器模式：" class="headerlink" title="16. 解释器模式："></a>16. 解释器模式：</h3><blockquote>
<p>给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。<br>示例：PackageParser这个类对AndroidManifest.xml这个配置文件的解析过程，</p>
</blockquote>
<h3 id="17迭代器模式"><a href="#17迭代器模式" class="headerlink" title="17迭代器模式"></a>17迭代器模式</h3><blockquote>
<p>提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。</p>
</blockquote>
<p>示例：在Android中除了各种数据结构体，如List，Map，等包含的迭代器以外，Android源码中也提供了迭代器遍历模式，比如数据库查询使用Cursor，当我们使用SQLiteDataBase的query方法查询数据库时，会返回一个Cursor游标对象，该游标对象实际上就是一个具体的迭代器。</p>
<h3 id="18-备忘录模式"><a href="#18-备忘录模式" class="headerlink" title="18 备忘录模式"></a>18 备忘录模式</h3><blockquote>
<p>不需要了解对象的内部结构的情况下备份对象的状态，方便以后恢复。</p>
</blockquote>
<p>示例：Activity的onSaveInstanceState和onRestoreInstanceState就是通过Bundle这种序列化的数据结构来存储Activity的状态，至于其中存储的数据结构，这两个方法不用关心。</p>
<h3 id="19-责任链模式"><a href="#19-责任链模式" class="headerlink" title="19.责任链模式"></a>19.责任链模式</h3><blockquote>
<p>有多个的对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定。</p>
</blockquote>
<p>示例:  责任链模式在Android源码中比较类似的实现莫过于对事件的分发处理，每当用户接触屏幕时候，Android都会将对应的事件包装成一个事件对象从ViewTree的顶部至上而下的分发传递。ViewGroup事件投递的递归调用就类似一条责任链，一旦寻找到责任者，那么就由责任者持有并消费该次事件，具体的体现在View的onTouchEvent方法中的返回值，如果OnTouchEvent返回false，那么意味着当前View不会是该次事件的责任人，将不会对该事件持有。</p>
<h3 id="20-状态模式："><a href="#20-状态模式：" class="headerlink" title="20. 状态模式："></a>20. 状态模式：</h3><blockquote>
<p>状态发生改变时，行为改变。</p>
</blockquote>
<p>示例：View.onVisibilityChanged方法，就是提供了一个状态模式的实现，允许在View的visibility发生改变时，引发执行onVisibilityChanged方法中的动作。</p>
<h3 id="21-策略模式"><a href="#21-策略模式" class="headerlink" title="21.策略模式"></a>21.策略模式</h3><blockquote>
<p>定义了一系列封装了算法、行为的对象，他们可以相互替换。</p>
</blockquote>
<p>示例：Java.util.List就是定义了一个增（add）、删（remove）、改（set）、查（indexOf）策略，至于实现这个策略的ArrayList、LinkedList等类，只是在具体实现时采用了不同的算法。但因为它们策略一样，不考虑速度的情况下，使用时完全可以互相替换使用。</p>
<h3 id="22-命令模式"><a href="#22-命令模式" class="headerlink" title="22.命令模式"></a>22.命令模式</h3><blockquote>
<p>把请求封装成一个对象发送出去，方便定制、排队、取消。<br>示例：Handler.post后Handler.handleMessage。</p>
</blockquote>
<h3 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h3><blockquote>
<p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。是基于继承的代码复用的基本模式。</p>
</blockquote>
</section></article></section><section class="comment"><div class="ds-thread" data-thread-key="2017/06/18/2017-06-18-Android设计模式/" data-title="Android设计模式" data-url="http://zaijiangwangzhuan.com/2017/06/18/2017-06-18-Android设计模式/"></div><script>var duoshuoQuery = {short_name:'chordblog'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
})()</script></section><footer></footer><!--include copyright--></body></html>