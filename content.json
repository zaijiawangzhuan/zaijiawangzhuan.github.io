{"meta":{"title":"C Blog","subtitle":null,"description":null,"author":"微信号:caishen2048","url":"http://zaijiangwangzhuan.com"},"pages":[{"title":"categories","date":"2018-07-21T09:38:30.000Z","updated":"2018-07-21T09:38:30.425Z","comments":true,"path":"categories/index.html","permalink":"http://zaijiangwangzhuan.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-07-21T09:38:22.000Z","updated":"2018-07-21T09:38:22.600Z","comments":true,"path":"tags/index.html","permalink":"http://zaijiangwangzhuan.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"恒大金融","slug":"fenghuang","date":"2018-11-20T05:48:05.000Z","updated":"2018-11-13T12:43:50.961Z","comments":true,"path":"2018/11/20/fenghuang/","link":"","permalink":"http://zaijiangwangzhuan.com/2018/11/20/fenghuang/","excerpt":"","text":"恒大金服任务号: 2004佣金30元 + 平台送 20,50,100代金券 + 投资收益世界500强恒大集团官方白平台.绝对安全靠谱 注意事项 必须通过活动链接 活动在2017年08月31日结束 任务流程 点击 “开始任务” 跳转到浏览器注册下载恒大金服App登陆 点击理财一选择新人专享或其他接近180天的标，按提示实名绑卡 投资100元，记得勾选20元现金券，实际支付80元 到期可提现105元. 任务提交内容: 注册名填写 注册手机号码 投资成功的截图或者交易详倩截图 .","categories":[],"tags":[]},{"title":"","slug":"test","date":"2018-11-13T12:45:23.377Z","updated":"2018-11-13T12:45:23.377Z","comments":true,"path":"2018/11/13/test/","link":"","permalink":"http://zaijiangwangzhuan.com/2018/11/13/test/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"test2","date":"2018-11-12T16:00:00.000Z","updated":"2018-11-13T12:46:21.038Z","comments":true,"path":"2018/11/13/test2/","link":"","permalink":"http://zaijiangwangzhuan.com/2018/11/13/test2/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-11-08T11:45:20.910Z","updated":"2017-10-28T00:39:58.000Z","comments":true,"path":"2018/11/08/hello-world/","link":"","permalink":"http://zaijiangwangzhuan.com/2018/11/08/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"shenqian","slug":"shenqian","date":"2018-09-20T05:48:05.000Z","updated":"2018-09-20T06:04:41.965Z","comments":true,"path":"2018/09/20/shenqian/","link":"","permalink":"http://zaijiangwangzhuan.com/2018/09/20/shenqian/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Android开源库整理","slug":"2017-08-30-Android开源库整理","date":"2017-08-30T08:00:00.000Z","updated":"2018-07-21T03:13:52.468Z","comments":true,"path":"2017/08/30/2017-08-30-Android开源库整理/","link":"","permalink":"http://zaijiangwangzhuan.com/2017/08/30/2017-08-30-Android开源库整理/","excerpt":"","text":"content{:toc} 图片加载库 (解决网络, 文件, res, assets等图片的获取, 解析, 展示, 缓存等需求…) 名称 概要 详情 *Picasso Github大神推荐的强大的图片下载和缓存库 Square 开源的项目,主导者是 JakeWharton. *Glide Google推荐的图片加载和缓存的库 专注于平滑滚动时的流畅加载, Google开源项目, 2014年Google I/O 上被推荐 *Fresco Facebook推荐的的Android图片加载库 自动管理图片的加载和图片的缓存.Facebook 在2015年上半年开源的图片加载库 *Android-Universal-Image-Loader 早期广泛使用的开源图片加载库 强大又灵活的Android库, 用于加载,缓存,显示图片. Volley 2013年Google I/O推荐的网络通讯框架 使用volley加载网络图片，主要用到其中的ImageLoader, NetworkImageView类, 注意它不仅仅是个图片加载库. Cube-sdk 轻量级的Android开发框架 高效方便地加载网络图片, 更简易地处理网络API请求 图片处理库 (解决图片缩放, 裁剪, 平移, 旋转等需求) 名称 概要 详情 PinchImageView 国人写的, 可能是体验最好的图片手势控件 支持双击放大，双击缩小,超出边界会回弹, 滑动惯性，不同分辨率无缝切换，可与ViewPager结合使用。 star:360 GestureViews 包含ImageView的自定义FrameLayout 项目目的是让图片的查看尽可能流畅平滑, 让开发者更加方便地集成到自己的应用中, 支持手势控制和动画 star:582 *PhotoView 致力于帮助开发者高效的创建可缩放的ImageView 重写ImageView的实现, 支持多点触摸的图片缩放 star:4705 subsampling-scale-image-view 一个Android自定义图片视图, 专为图片画廊设计 丰富的配置选项, 更方便的实现图片的手势缩放, 旋转, 平移. 无损展示大图, 完美的地嵌入画廊, 地图等.可显示大图(地图, 建筑设计图)等而不造成OutOfMemoryErrors(OOM内存溢出异常) star:1137 TouchImageView 一个ImageView的拓展类 支持ImageView所有功能, 添加了平移, 缩放, 拖拽, 滑动, 双击缩放等动画.star:1252 ImageViewZoom 自定义ImageView控件 一个可以缩放, 平移的自定义ImageView控件. star:1080 网络编程网络加载框架 解决各种协议(GET, POST, PUT, HEAD, DETELE…)的网络数据的获取及请求, 支持异步,同步请求; 文件多线程下载断点续传, 上传; 请求自动重试, gzip压缩, Cookies自动解析并持久化. 数据的缓存. 目标是让网络请求更方便, 简介, 高效, 稳定. 名称 概要 详情 *Retrofit2.0 以接口/注解的形式定义请求和响应 Square 开源的项目. 是一套RESTful架构的Android(Java)客户端实现，基于注解，提供JSON to POJO(Plain Ordinary Java Object,简单Java对象)，POJO to JSON，网络请求(POST，GET,PUT，DELETE等)封装。 Jake Wharton大神力荐. 本身的网络核心可以替换. 如Apache HTTP client, URL connection, OKHttp等, 数据解析核心也可以替换如Gson, Jackson, fastjson, xStream等. 力求用最少的代码, 实现最强大的功能. 官方主页 *okhttp 一个为安卓和java应用诞生的Http+SPDY的网络处理库 square开源项目. a. 支持HTTP, HTTPS, HTTP/2.0, and SPDY协议 b. 自动缓存数据, 节省流量, c.内部自动GZIP压缩内容. android-async-http 一个异步的AndroidHttp库 比较经典的网络请求库, 基于Apache的HttpClient库实现, 但是由于AndroidM(6.0)去除了对HttpClient相关API, 意味着google不再推荐使用. Volley 一个能让Android的网络请求更简单快捷的Http库 官方地址, 需翻墙 Volley集成了AsyncHttpClient和Universal-Image-Loader的优点，既可以像AsyncHttpClient一样非常简单地进行HTTP通信，也可以像Universal-Image-Loader一样轻松加载网络上的图片。但是对大数据量的网络操作如文件的下载支持较差 动画 名称 概要 详情 Lottie Airbnb 名称 概要 详情 gifview Airbnb","categories":[{"name":"Android","slug":"Android","permalink":"http://zaijiangwangzhuan.com/categories/Android/"}],"tags":[{"name":"第三方","slug":"第三方","permalink":"http://zaijiangwangzhuan.com/tags/第三方/"}]},{"title":"Android免商店应用架构","slug":"2017-08-28-Android免商店应用架构","date":"2017-08-28T08:00:00.000Z","updated":"2018-07-21T03:13:52.467Z","comments":true,"path":"2017/08/28/2017-08-28-Android免商店应用架构/","link":"","permalink":"http://zaijiangwangzhuan.com/2017/08/28/2017-08-28-Android免商店应用架构/","excerpt":"","text":"content{:toc} Android免商店应用架构分包大体使用MVC 架构，按照基础支持功能和业务功能 来分包 第一层 com.company(公司域名) + app(应用程序名) 第二层 各模块包名, 基础支持功能+ 业务模块功能12345678910111213141516171819202122232425com.company.app |-- common |-- config 配置 |-- AppConstants.java 存放应用程序的根配置，比如版本，目标配置等等 |-- widget |-- model 公共model |-- adapter 公共的adpter |-- base |-- BaseApplication.java |-- BaseActivity.java 定义一些基础 Activity 和 抽象方法 |-- BaseFragment.java |-- db 数据库 |-- network 网络请求 |-- home 首页模块 |-- model |-- adapter |-- HomeFragment.java |-- ... |-- personal 个人中心模块 |-- model |-- adapter |-- PersonalFragment.java |-- support 支持模块，如升级 反馈 分享 |-- utils 工具类库与业务无关的公共方法 |-- MainActivity.java 第三方库 注解: ButterKnife 网络: Volley 图片加载: fresco 通信: otto 解析Json: fastjson 解析网页: jsoup 生成GetSet： Lombok 数据库: OrmLite 检查内存溢出: leakcanary 异步操作: RXJava 工具类第三方 统计: Umeng 错误: Testing 人脸识别: face++ 地图: 高德api 推送: 个推 二维码识别: Zbar View 相关第三方 动画兼容: nineoldandroids 底部弹出菜单: BottomSheet List多个布局 : MergeAdapter 侧滑退出: swipebacklayout 图片处理: simplecropimage 带指示器的Viewpage: viewpagerindicator 列表项隐藏显示: slideexpandable 下拉刷新库: android-Ultra-Pull-To-Refresh 高斯模糊: NativeStackBlur","categories":[{"name":"Android","slug":"Android","permalink":"http://zaijiangwangzhuan.com/categories/Android/"}],"tags":[{"name":"架构","slug":"架构","permalink":"http://zaijiangwangzhuan.com/tags/架构/"}]},{"title":"Android博客精选","slug":"2017-08-29-Android博客精选","date":"2017-08-09T08:00:00.000Z","updated":"2018-07-21T03:13:52.468Z","comments":true,"path":"2017/08/09/2017-08-29-Android博客精选/","link":"","permalink":"http://zaijiangwangzhuan.com/2017/08/09/2017-08-29-Android博客精选/","excerpt":"","text":"content{:toc} 官方Android官方培训课程中文版 插件化Android热修复实践应用–AndFix 技术管理的路","categories":[{"name":"Android","slug":"Android","permalink":"http://zaijiangwangzhuan.com/categories/Android/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://zaijiangwangzhuan.com/tags/学习/"}]},{"title":"Android开发工具秘籍","slug":"2017-08-02-Android开发工具秘籍","date":"2017-08-02T08:00:00.000Z","updated":"2018-07-21T03:13:52.466Z","comments":true,"path":"2017/08/02/2017-08-02-Android开发工具秘籍/","link":"","permalink":"http://zaijiangwangzhuan.com/2017/08/02/2017-08-02-Android开发工具秘籍/","excerpt":"","text":"content{:toc} 1.无线调试运行 还在为在使用真机测试时，缺乏数据线而发愁吗？ 还为每次用数据线连接真机测试时，都得抽拔抽拔烦不胜烦 神器来了,Android ADB WIFI 插件 支持 Intellij / Android Studio ,这个是开源项目 源码地址 https://github.com/pedrovgs/AndroidWiFiADB 如何安装 Intellij / Android Studio: Preferences/Settings-&gt;Plugins-&gt;Browse Repositories-&gt;搜索Android ADB WIFI 如何使用 将调试手机通过USB 连接上电脑. 点击Intellij / Android Studio 刚安装的 Android ADB WIFI 按钮 此时会出现 “Device *** connected” 提示 Ok！！！下面拔掉你的数据线，运行APP看看效果。 当然 如果手机root了，可以在应用市场搜索 wifi adb 下载安装 2.显示当前Acitivity 有一天老板要你把应用某个界面的文字放大一点 位置移动一下，然这个模块又不是你做的， 是不是一脸闷 怎么快速定位当前界面的Activity呢 神器来了， 显示当前顶端的Activity，快速定位到当前界面。 链接地址:https://github.com/fashare2015/ActivityTracker 亦可通过下方cmd 命令来显示 推荐有逼格 查看当前Activity ：adb shell “dumpsys window w &#124; grep name=” 查看当前栈顶的Activity ：adb shell “dumpsys activity &#124; grep mFocusedActivity” 查看当前栈顶的Activity的Fragment ：adb shell dumpsys activity your.package.name 3. 开发助手 —— 方便切换开发者配置Trinea 大神佳作，在此不过多介绍，详情请看： Android 应用开发调试利器——开发助手，数十倍效率提升 4.电脑端更改Hosts 有时候需要更换hosts 来实现内外网切换 SwitchHosts! 是一个管理、切换多个 hosts 方案的工具。它是一个免费开源的软件下载地址: http://www.xiazaiba.com/html/23970.html 5.抓包工具 有一天 测试部门过来说 这个界面某个数据有问题, 你想看一下 服务器传过来的数据是咋样的? 还在通过调试方法看log 得到 Charles 在做移动开发时，我们为了调试与服务器端的网络通讯协议，常常需要截取网络封包来分析。支持MAC和Windows 划重点: charles和 上面的switchHosts 一起使用可以实现手机非root 切换hosts6.打包工具 我们在开发Android时，经常会遇到的一个问题就是多渠道打包，这个是很烦躁的问题，因为如果使用AndroidStudio中的productFlavors去进行生成多渠道包，这个是非常耗时的。 美团之前提供了一个创建以渠道号为名的空文件夹塞到apk中, 现在这种方法在7.0里面失效了 现在美团又提供了一个写id的方法 美团官方技术博客 美团打包github","categories":[{"name":"Android","slug":"Android","permalink":"http://zaijiangwangzhuan.com/categories/Android/"}],"tags":[{"name":"开发工具","slug":"开发工具","permalink":"http://zaijiangwangzhuan.com/tags/开发工具/"}]},{"title":"Android动态加载皮肤","slug":"2018-07-18-Android动态加载皮肤","date":"2017-07-18T08:00:00.000Z","updated":"2018-07-21T03:13:52.469Z","comments":true,"path":"2017/07/18/2018-07-18-Android动态加载皮肤/","link":"","permalink":"http://zaijiangwangzhuan.com/2017/07/18/2018-07-18-Android动态加载皮肤/","excerpt":"","text":"content{:toc} Android免商店动态加载皮肤概述应用提供皮肤功能，可以作为应用推广和用户个性化的方案。免商店提供皮肤动态切换和加载，极大的提升了用户使用体验，也为新品推广提供一种途径。 Android内使用皮肤即主题有几种方式： 自带Theme及Style 使用已安装皮肤应用的Theme等资源 动态加载皮肤包apk由于第一种是使用应用内资源，需要每次应用更新才能使用新主题等资源，不能随时动态加载，并不方便灵活。而第二种需要安装皮肤包apk，对用户使用感受影响较大，故也不考虑。免商店选择了第三种动态加载皮肤包，这种方式灵活且对用户透明，缺点是开发周期较长。对于需要不定期推广和低用户感知的免商店来说，第三种方式更好。 动态加载原理 在Android中，所有的资源都是基于包的。资源以id进行标识，在同一个应用中，每个资源都有唯一标识。每个资源都可以通过Context对象的方法getRsources获取到其绑定的资源对象，然后，就可以使用Resources的getXXX方法获取字符串、颜色、dimension、图片等。 而Resources类也是通过AssetManager类来访问那些被编译过的应用程序资源文件的，不过在访问之前，它会先根据资源ID查找得到对应的资源文件名。需要注意的是，AssetManager可以通过无参实例化并反射调用addAssetPath方法，该方法用来添加assets的路径，这个路径就是我们皮肤包的路径。 至此，皮肤包的资源调用就完成了。 以下是参考代码范例。1234567891011121314151617//获取AssetManagerprivate AssetManager createAssetManager(String dexPath) &#123; try &#123; AssetManager assetManager = AssetManager.class.newInstance(); Method addAssetPath = assetManager.getClass().getMethod(&quot;addAssetPath&quot;, String.class); addAssetPath.invoke(assetManager, dexPath); return assetManager; &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125;&#125;//获取皮肤包的Resourcesprivate Resources createResources(AssetManager assetManager) &#123; Resources superRes = mContext.getResources(); return new Resources(assetManager, superRes.getDisplayMetrics(), superRes.getConfiguration());&#125; 皮肤包可通过与免商店约定资源名来获取资源。通过调用皮肤包的Resource对象内getIdentifier方法，传入约定的资源名，获取资源ID，再通过调用getXXX获取资源。以下是参考代码范例，本例返回了一个Drawable对象。12345678910int resId = resources.getIdentifier(resName, null, null);if (resId &gt; 0) &#123; try &#123; return skinPluginPackage.resources.getDrawable(resId); &#125; catch (OutOfMemoryError e) &#123; return null; &#125;&#125; else &#123; return null;&#125; 开发说明1. 皮肤模块初始化 皮肤模块在MainActivity启动时进行了加载，并由图中工具类SystemConfigUtil获取配置在后端的皮肤信息，执行下载皮肤和加载过程。 2.皮肤包加载 当皮肤管理类SkinManager加载一个皮肤包时，调用loadSkinPackage方法并传入皮肤包apk的本地路径 调用插件管理类PluginManager的loadApk方法，内部依次通过调用方法createDexClassLoader -&gt; createAssetManager -&gt; createResources分别实例化了DexClassLoader、AssetManager、Resources对象，作为获取皮肤包内资源的基础。 返回SkinManager内，再次调用PluginManager的removePackage方法，释放已加载的皮肤资源。 执行loadSkinPackageConfig方法，加载当前可用皮肤配置。 执行notifySkinChange方法，方法内部遍历通知所有注册监听皮肤加载事件的监听对象，以便这些对象能根据当前皮肤切换。12345678910111213private PluginPackage preparePluginEnv(PackageInfo packageInfo, String dexPath) &#123; PluginPackage pluginPackage = mPackagesHolder.get(packageInfo.packageName + packageInfo.versionCode); if (pluginPackage != null) &#123; return pluginPackage; &#125; DexClassLoader dexClassLoader = createDexClassLoader(dexPath); AssetManager assetManager = createAssetManager(dexPath); Resources resources = createResources(assetManager); // create pluginPackage pluginPackage = new PluginPackage(dexClassLoader, resources, packageInfo); mPackagesHolder.put(pluginPackage.packageName + pluginPackage.versionCode, pluginPackage); return pluginPackage;&#125; 3.主要类功能说明 SkinPackage 后端配置的皮肤信息，包括皮肤包下载地址、大小、包名、MD5、版本号，有效日期等信息，供下载使用。 PluginPackage皮肤包加载后的对象，维护DexClassLoader、AssetManager、Resources等信息，供获取包内资源使用。 SkinManager该类为皮肤管理类，为单例类。维护着所有监听皮肤加载事件的监听对象，以及当前后端配置的活动皮肤（SkinPackage）和对应皮肤包（PluginPackage）信息。类提供加载皮肤包、注册/注销监听对象、清理过期皮肤的方法，以及获取皮肤包内资源的方法。 PluginManager该类为皮肤包加载类，用来维护所有皮肤包（PluginPackage）信息，并对外提供唯一方法loadApk用来加载皮肤包。方法内分别实例化了DexClassLoader、AssetManager、Resources对象用来获取皮肤包内资源。 SkinDownloadServices本类为皮肤下载服务类，当收到下载请求时，调用下载服务下载皮肤包。监听下载完成通知并调用SkinManager内方法加载皮肤包PluginPackage，并在加载完成后保存至数据库皮肤表中。 ISkinColor、ISkinDrawable监听皮肤加载事件的接口对象，对象设定监听的资源ID，当皮肤加载时被回调，根据该ID从皮肤包内获取资源并返回给本对象。 新增一个皮肤包下面介绍了怎样给免商店应用增加一个皮肤包用来换肤。 修改免商店为了便于开发，所有需要换肤的资源使用与免商店同一name，这样当加载皮肤包资源时仅需提供该同名资源名。以左侧菜单栏换肤为例，菜单栏需要更换背景图片及部分字体颜色。123456789101112131415161718192021iSkinDrawables.add(new ISkinDrawable() &#123; @Override public int getDrawableResId() &#123; return R.drawable.menu_account_bg; &#125; @Override public void onDrawableChanged(Drawable drawable) &#123; if (mAccountContainer != null) &#123; mAccountContainer.setBackgroundDrawable(drawable); &#125; &#125; @Override public String getTag() &#123; return TAG; &#125; &#125;);for (ISkinDrawable iSkinDrawable : iSkinDrawables) &#123; SkinManager.getInstance().registerSkinables(iSkinDrawable); &#125; 1.实例化一个ISkinDrawable对象。2.方法getDrawableResId返回主应用内该drawable的id，3.方法onDrawableChanged接收回调时传回的drawable对象，当不为null时直接设置即可4.方法getTag返回一个字符串，用来注销监听时移除该ISkinDrawable对象。5.增加到iSkinDrawables监听队列，并注册队列中所有监听对象。颜色：12345678910111213141516171819202122232425iSkinColors.add(new ISkinColor() &#123; @Override public int getColorResId() &#123; return R.color.menu_title_color; &#125; @Override public void onColorChanged(int color) &#123; if (slideMenuAdapter != null) &#123; slideMenuAdapter.setMenuTitleColor(color); slideMenuAdapter.notifyDataSetChanged(); &#125; if (mMyWalletTitleView != null) &#123; mMyWalletTitleView.setTextColor(color); &#125; &#125; @Override public String getTag() &#123; return TAG; &#125; &#125;);for (ISkinColor iSkinColor : iSkinColors) &#123; SkinManager.getInstance().registerSkinables(iSkinColor); &#125; 1.实例化一个ISkinColor对象。2.其他步骤类似图片方式。 新建皮肤工程由于皮肤包用来替换主应用的主题相关资源，所以只要新建一个工程，在资源目录res下增加图片、字符串、颜色等即可。图片： 在drawable下新增一个同一资源名的图片或xml，支持不同分辨率目录下放置合适图片及其他drawable资源。颜色： 在color.xml配置同一资源名的color资源，与普通颜色设置相同。新增完成后，直接打包并签名，即可得到生成的皮肤包apk。 服务端配置参考运营提供的配置页面说明。将生成的皮肤包上传至服务端，并将该皮肤配置在有效期且状态为有效，其他皮肤配置禁用即可。","categories":[{"name":"Android","slug":"Android","permalink":"http://zaijiangwangzhuan.com/categories/Android/"}],"tags":[{"name":"黑科技","slug":"黑科技","permalink":"http://zaijiangwangzhuan.com/tags/黑科技/"}]},{"title":"Kotlin学习","slug":"2017-07-17-Kotlin学习","date":"2017-07-17T08:00:00.000Z","updated":"2018-07-21T03:13:52.465Z","comments":true,"path":"2017/07/17/2017-07-17-Kotlin学习/","link":"","permalink":"http://zaijiangwangzhuan.com/2017/07/17/2017-07-17-Kotlin学习/","excerpt":"","text":"content{:toc} kotlin 比较重要的两个网站Kotlinlang.orgKotlin Koans Online: 一个可以通过在线编程学习kotlin网站 类 声明 1class Invoice&#123;&#125; 构造函数 12345class Person constructor(firstName: String)&#123; init&#123; ... &#125;&#125; 主构造函数不能包含任何代码，可以放到init 关键字 初始化块中","categories":[{"name":"Android","slug":"Android","permalink":"http://zaijiangwangzhuan.com/categories/Android/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://zaijiangwangzhuan.com/tags/学习/"}]},{"title":"Android网站收录","slug":"2017-07-14-Android网站收录","date":"2017-07-14T08:00:00.000Z","updated":"2018-07-21T03:13:52.465Z","comments":true,"path":"2017/07/14/2017-07-14-Android网站收录/","link":"","permalink":"http://zaijiangwangzhuan.com/2017/07/14/2017-07-14-Android网站收录/","excerpt":"","text":"content{:toc} Android 源码在线阅读 网站收录泡在网上的日子 遇到的问题HttpUrlConnection支持Header,Body传值，支持Multipart上传文件解决android 6.0 webview加载https出现空白页问题 在github pages网站下用jekyll制作博客教程","categories":[{"name":"Android","slug":"Android","permalink":"http://zaijiangwangzhuan.com/categories/Android/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://zaijiangwangzhuan.com/tags/学习/"}]},{"title":"Android知识集合","slug":"2017-06-20-Android知识集合","date":"2017-06-20T08:00:00.000Z","updated":"2018-07-21T03:13:52.464Z","comments":true,"path":"2017/06/20/2017-06-20-Android知识集合/","link":"","permalink":"http://zaijiangwangzhuan.com/2017/06/20/2017-06-20-Android知识集合/","excerpt":"","text":"content{:toc} Activity的几种LaunchMode及使用场景standard 模式 这是默认模式，每次激活Activity时都会创建Activity实例，并放入任务栈中。使用场景：大多数Activity。 singleTop 模式如果在任务栈顶正好存在改Activity ，就重用该Activity( 会调用实例的 onNewIntent() ), 使用场景 如通知栏 点击重复进入Activity singleTask 模式如果任务栈堆 有该Activity 就重用该实例，重用时 会让该实例回到栈顶 ，之前在它上面的实例会被移除 使用场景如 主界面 需要清空上面所有activity的情况 singleInstance单一实例模式， 整个手机操作系统只有一个实例 使用场景如: 呼叫来电 如何理解Activity，View，Window三者之间的关系？ Activity 是android 应用组件，提供一个屏幕 共用户交互 。每个activity会给于一个窗口 在上面可以绘制view 1: Activity构造的时候会初始化一个Window，准确的说是PhoneWindow。 2: 这个PhoneWindow有一个“ViewRoot”，这个“ViewRoot”是一个View或者说ViewGroup，是最初始的根视图。 3：“ViewRoot”通过addView方法来一个个的添加View。比如TextView，Button等 4：这些View的事件监听，是由WindowManagerService来接受消息，并且回调Activity函数。比如onClickListener，onKeyDown等。 Activity 层级关系：每个Activity包含一个PhoneWindow对象，PhoneWindow设置DecorView为应用窗口的根视图。在里面就是熟悉的TitleView和ContentView,没错，平时使用的setContentView()就是设置的ContentView 启动service的两种方法和区别startService 和 bindService， startService 启动后即与调用者没关系了 关闭需调用stopService, bindService与调用者绑定在一起可以进行通信 关闭了调用者服务也退出了 Service 是否在 main thread 中执行, service 里面是否能执行耗时的操作RecyleView 和 ListViewAndroid TouchEvent事件分发机制 函数 作用 dispatchTouchEvent() 用来分派事件。其中调用了onInterceptTouchEvent()和onTouchEvent()，一般不重写该方法 onInterceptTouchEvent() 用来拦截事件。ViewGroup类中的源码实现就是{return false;}表示不拦截该事件，事件将向下传递（传递给其子View）；若手动重写该方法，使其返回true则表示拦截，事件将终止向下传递，事件由当前ViewGroup类来处理，就是调用该类的onTouchEvent()方法 onTouchEvent（） 用来处理事件。返回true则表示该View能处理该事件，事件将终止向上传递（传递给其父View）；返回false表示不能处理，则把事件传递给其父View的onTouchEvent()方法来处理 TouchEvent事件分发机制 Android View的绘制流程可以经过三个过程 measure、layout、draw 过程参考链接 Android 跨进程通讯的几种方式1.通过Intent访问其他应用程序Activity Content Provider 访问系统相册 广播 AIDL 服务 Handler的原理 使用场景 handler 一般用于延时操作或接收子线程发送的数据， 用此数据配合主线程更新UI。 原理: Looper负责创建MessageQueue 然后无限循环的从MessageQueue中读取 handler发过来的消息 参考链接 Binder机制原理参考链接 AsyncTask 相关AsynTask内部实行 使用场景内部是通过Handler 机制来完成，Android提供执行框架来提供线程池执行相关任务，因为线程池的大小问题 只能执行耗时短的任务如http请求对于大规模下载不适用AysncTask会造成线程池堵塞 发现AysncTask执行不了 1.AsynTask为什么要设计为只能够一次任务？ 最核心的还是线程安全问题，多个子线程同时运行，会产生状态不一致的问题。所以要务必保证只能够执行一次 2.AsynTask造成的内存泄露的问题怎么解决 比如非静态内部类AsynTask会隐式地持有外部类的引用，如果其生命周期大于外部activity的生命周期，就会出现内存泄漏注意要复写AsynTask的onCancel方法，把里面的socket，file等，该关掉的要及时关掉在 Activity 的onDestory()方法中调用Asyntask.cancal方法Asyntask内部使用弱引用的方式来持有Activity 3. 若Activity已经销毁，此时AsynTask执行完并且返回结果，会报异常吗? 当一个App旋转时，整个Activity会被销毁和重建。当Activity重启时，AsyncTask中对该Activity的引用是无效的，因此onPostExecute()就不会起作用，若AsynTask正在执行，折会报 view not attached to window manager 异常同样也是生命周期的问题，在 Activity 的onDestory()方法中调用Asyntask.cancal方法，让二者的生命周期同步 4. Activity销毁但Task如果没有销毁掉，当Activity重启时这个AsyncTask该如何解决？还是屏幕旋转这个例子，在重建Activity的时候，会回掉Activity.onRetainNonConfigurationInstance()重新传递一个新的对象给AsyncTask，完成引用的更新 ANR应用程序在一段时间不够灵敏，系统就会显示一个对话框 产生的原因: 来自AMS的回调消息 当AMS对应用组件的生命周期进行回调的时间超过自定义的响应时间就会包ANR，回调函数及超过时间如下: 12345678Activity: onCreate(), onResume(), onDestroy(), onKeyDown(), onClick()等，超时时间5sApplication: onCreate(), onTerminate()等，超时时间5sService: onCreate(), onStart(), onDestroy()等，超时时间20sBroadcastReceiver：onReceiver()，前台APP广播超时时间是10s，后台App是60s App 其他操作运行在UI线程的 123AsyncTask: onPreExecute(), onProgressUpdate(), onPostExecute(), onCancel()等，超时5sMainthread handler: handleMessage(), post*(runnable r)等，超时5s 如何避免 耗时操作放入子线程中 使用handler 来处理UI 线程和其他线程的交互 参考链接 Android内存泄漏当一个对象已经不需要使用了，本该回收的时候，另一个正在使用的对象持有它的引用导致它不能被回收 这不能回收的对象就在推内存中，就产生了内存泄漏 当内存超出系统分配的内存限额 引用就会Crash 常见内存泄漏汇总 单例造成的内存泄漏 非静态内部类 创建静态实例造成的内存泄漏 Handler造成的内存泄漏 线程造成的泄漏 资源未关闭造成的内存泄漏 参考链接 布局优化1.合理选择控件容器， 尽量减少层次 相同层次使用LinearLayout 去掉window的默认背景 去掉其他不别要的背景4.ViewStub 高效占位符， 对于比较复杂的需要显示隐藏的布局 可以通过viewStub 控制 Merge 图片优化一些优化方案 非重点参考链接 图片缓存内存缓存 LruCache + 磁盘缓存 DiskLruCache + 网络请求 组成三级缓存 热修复原理设计模式MVC MVP MVVM 设计架构参考链接 RXJAVA","categories":[{"name":"Android","slug":"Android","permalink":"http://zaijiangwangzhuan.com/categories/Android/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://zaijiangwangzhuan.com/tags/面试/"}]},{"title":"Java知识集合","slug":"2017-06-19-Java知识集合","date":"2017-06-19T08:00:00.000Z","updated":"2018-07-21T03:13:52.463Z","comments":true,"path":"2017/06/19/2017-06-19-Java知识集合/","link":"","permalink":"http://zaijiangwangzhuan.com/2017/06/19/2017-06-19-Java知识集合/","excerpt":"","text":"content{:toc} 接口和抽象类的意义抽象类一般用于抽象出共有特性比如 亚洲人和人接口一般用于某种特殊 操作的特性 比如女人生娃 JAVA GC（回收）原理JAVA 通过GC 确认对象是否被其他引用 确定是否收集该对象 触发的条件（时间）1.GC在优先级最低的线程中运行 所以在应用程序空闲的时候被调用2.当JAVA堆内存不足的时候 对谁回收把内存分为几块，年轻化 老年块， 对年轻块使用效率较高的算法 如果对象经过几轮都没被回收就进入老年块 采用不同的算法回收 减少GC开销的措施 减少临时对象的使用 对象不用的时候设置为null 对于操作string 尽量用stringbuffer 少用静态对象变量 能用基本内形用基本内形 JAVA 反射原理参考链接 volatile强引用 软引用 弱引用 虚引用 强引用: 不会被回收 即使当前内存不足 软引用SoftReference: 内存足够继续使用，当内存不足时会回收 比如图片加载框架 弱引用WeakReference: JVM(Java 虚拟机)进行垃圾回收时 无论内存是否充足就会被回收比如Handler持有Activity 虚拟用: 对象经常使用就使用软引用，如果不被使用的可能性更大 就是用弱引用 String StringBuffer 与StringBuilder的区别String 是不可变的对象 ,StringBuffer和 StringBuilder底层是char[]数组实现的，StringBuffer是线程安全 StringBuilder是线程不安全 用过哪些集合类有哪些数组 和 链表 ArrayList,LinkedList Vector的区别ArrayList 基于动态数组的数据结构 get set有优势 线程不同步不过性能好LinkedList 基于链表的数据结构 新增和删除有优势Vector 基于数据的数据结构 线程同步 Thread中sleep 和 wait 区别sleep 不会释放对象所 wait会释放对象所sleep 不会出让系统资源 wait可以占有sleep 需要指定一个睡眠时间 排序算法 排序算法 思想 冒泡排序 两个数比较大小，较大的数下沉，较小的数冒起来 选择排序 在长度为N的无序数组中，第i++次遍历n-i个数，找到最小的数值与i元素交换 插入排序 假定前n-1个数已经排好序，现在将第n个数插到前面的有序数列中 希尔排序 某一增量分为若干子序列 对子序列插排 然后减小增量再插排 快速排序 从数列中取一个数 小的放左边大的放右边，再对左右两边重复这个操作 归并排序 堆排序 参考链接","categories":[{"name":"Java","slug":"Java","permalink":"http://zaijiangwangzhuan.com/categories/Java/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://zaijiangwangzhuan.com/tags/面试/"}]},{"title":"Android设计模式","slug":"2017-06-18-Android设计模式","date":"2017-06-18T08:46:00.000Z","updated":"2018-07-21T03:13:52.463Z","comments":true,"path":"2017/06/18/2017-06-18-Android设计模式/","link":"","permalink":"http://zaijiangwangzhuan.com/2017/06/18/2017-06-18-Android设计模式/","excerpt":"","text":"content{:toc} 按照 设计模式定义–&gt; 通常在什么情况使用 –&gt; 示例 设计模式 （1）基本定义：设计模式（Design pattern）是一套被反复使用的代码设计经验的总结。使用设计模式的目的是为了可重用代码、让代码更容易被他人理解。设计模式是是软件工程的基石脉络，如大厦的结构一样。 （2）Design pattern的四大要素：模式名称（Name），问题（Question），解决方案（Solution），效果（Efftive）。 （3）OO（面向对象）的六大原则：单一职责原则，开闭原则，里氏替换原则，依赖倒置原则，接口隔离原则，迪米特原则。 单一职责原则：一个类中应该是一组相关性很高的函数，数据的封装。两个完全不一样的功能就不应该放在一个类中。 开闭原则：对修改封闭，对扩展放开。 里氏替换原则：抽象和继承；所有引用基类的地方必须能透明的使用其子类的对象。 依赖倒置原则：抽象不应该依赖细节，细节应该依赖抽象。 接口隔离原则：将大接口改成多个小接口。 迪米特原则：也称为最少知识原则，一个对象应该对另一个对象有最少的了解。 设计模式的分类设计模式分为三种类型： （1）创建型模式5种：单例模式，抽象工厂模式，工厂模式，原型模式，建造者模式。（口诀：单原建造者，东西二厂） （2）结构型模式7种：适配器模式，桥接模式，装饰模式，组合模式，外观模式，享元模式，代理模式。（口诀：一器一桥一元一代理；装饰组合外观） （3）行为型模式11种：观察者模式，中介者模式，访问者模式，解释器模式，迭代器模式，备忘录模式，责任链模式，状态模式，策略模式，命令模式，模板模式。（口诀：三者两器、一录一链一模板，状态策略命令） 1. 单例模式 确保一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。 App 只需要一个类 实例，或者类的初始化操作比较耗费资源， 不如 网络加载和 图片加载 Android中的系统级服务都是通过容器的单例模式实现方式，以单例形式存在，减少了资源消耗 如 LayoutInflater Service， ActivityManager InputMethodManager AccessibilityManager 中 getInstance 都是单例 示例1234567891011121314151617public class Singleton &#123; private static volatile Singleton instance = null; private Singleton()&#123; &#125; public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 2.Builder(建造者)模式 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示 一个类的构造需要很多参数，而且这些参数都不是必须的，就比较适合Builder Android中最常用的就是Dialog的构建，Notification的构建也是标准的建造者模式。 示例12345678910111213141516171819202122232425262728293031323334353637383940414243public class Person &#123; private String name; private int age; private double height; private double weight; privatePerson(Builder builder) &#123; this.name=builder.name; this.age=builder.age; this.height=builder.height; this.weight=builder.weight; &#125; @Get @Set static class Builder&#123; private String name; private int age; private double height; private double weight; public Builder name(String name)&#123; this.name=name; return this; &#125; public Builder age(int age)&#123; this.age=age; return this; &#125; public Builder height(double height)&#123; this.height=height; return this; &#125; public Builder weight(double weight)&#123; this.weight=weight; return this; &#125; public Person build()&#123; return new Person(this); &#125; &#125;&#125; 这样创建Person 类就可以这样 1234567 Person.Builder builder=new Person.Builder();Person person=builder .name(&quot;张三&quot;) .age(18) .height(178.5) .weight(67.4) .build(); 3. 工厂方法模式 定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类。 示例：BitmapFactory位图工厂，专门用来将指定的图片转换为指定的位图Bitmap。 4. 抽象工厂模式 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 Android底层对MediaPlayer的创建。MediaPlayerFactory是Android底层为了创建不同的MediaPlayer所定义的一个类。 5. 原型模式 用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象 比如我们需要一张Bitmap的几种不同格式：ARGB_8888、RGB_565、ARGB_4444、ALAPHA_8等。那我们就可以先创建一个ARGB_8888的Bitmap作为原型，在它的基础上，通过调用Bitmap.copy(Config)来创建出其它几种格式的Bitmap。另外一个例子就是Java中所有对象都有的一个名字叫clone的方法，已经原型模式的代名词了。在系统中要创建大量的对象，这些对象之间具有几乎完全相同的功能，只是在细节上有一点儿差别。 6. 适配器模式 将一个类的接口转换成客户希望的另外一个接口 不同的数据提供者使用一个适配器来向一个相同的客户提供服务。ListView或GridView的Adapter。 7. 组合模式 将对象组合成树形结构以表示“部分-整体”的层次结构。 示例：View和ViewGroup的组合 8.桥接模式 将抽象部分与它的实现部分分离，使它们都可以独立地变化 示例：Window和WindowManager之间的关系。在FrameWork中Window和PhoneWindow构成窗口的抽象部分，其中Window类为该抽象部分的抽象接口，PhoneWindow为抽象部分具体的实现及扩展。而WindowManager则为实现部分的基类，WindowManagerImpl则为实现部分具体的逻辑实现。 9. 装饰模式 动态地给一个对象添加一些额外的职责。就扩展功能而言， 它比生成子类方式更为灵活。 示例：Activity继承自ContextThemeWrapper，ContextThemeWrapper继承自ContextWrapper，ContextWrapper才是继承自Context。ContextWrapper就是我们找的装饰者。 10.外观模式 为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，统一编程接口。 示例：ContextImpl 11.享元模式 运用共享技术有效地支持大量细粒度的对象 示例：Message.obtainMessage通过重用Message对象来避免大量的Message对象被频繁的创建和销毁。 12. 代理模式 为其他对象提供一个代理以控制对这个对象的访问。 示例：所有的AIDL都一个代理模式的例子。假设一个Activity A去绑定一个Service S，那么A调用S中的每一个方法其实都是通过系统的Binder机制的中转，然后调用S中的对应方法来做到的。Binder机制就起到了代理的作用。 13. 观察者模式 一个对象发生改变时，所有信赖于它的对象自动做相应改变。 示例：我们可以通过BaseAdapter.registerDataSetObserver和BaseAdapter.unregisterDataSetObserver两方法来向BaseAdater注册、注销一个DataSetObserver。这个过程中，DataSetObserver就是一个观察者，它一旦发现BaseAdapter内部数据有变量，就会通过回调方法DataSetObserver.onChanged和DataSetObserver.onInvalidated来通知DataSetObserver的实现类。事件通知也是观察者模式。 14. 中介者模式 用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。示例：Binder机制。 15.访问者模式: 表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。 示例：编译时注解中的ElementVisitor中定义多个Visit接口，每个接口处理一种数据类型，这就是典型的访问者模式，访问者模式正好解决了数据结构和数据操作分离的问题，避免某些操作污染了数据对象类。 16. 解释器模式： 给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。示例：PackageParser这个类对AndroidManifest.xml这个配置文件的解析过程， 17迭代器模式 提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。 示例：在Android中除了各种数据结构体，如List，Map，等包含的迭代器以外，Android源码中也提供了迭代器遍历模式，比如数据库查询使用Cursor，当我们使用SQLiteDataBase的query方法查询数据库时，会返回一个Cursor游标对象，该游标对象实际上就是一个具体的迭代器。 18 备忘录模式 不需要了解对象的内部结构的情况下备份对象的状态，方便以后恢复。 示例：Activity的onSaveInstanceState和onRestoreInstanceState就是通过Bundle这种序列化的数据结构来存储Activity的状态，至于其中存储的数据结构，这两个方法不用关心。 19.责任链模式 有多个的对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定。 示例: 责任链模式在Android源码中比较类似的实现莫过于对事件的分发处理，每当用户接触屏幕时候，Android都会将对应的事件包装成一个事件对象从ViewTree的顶部至上而下的分发传递。ViewGroup事件投递的递归调用就类似一条责任链，一旦寻找到责任者，那么就由责任者持有并消费该次事件，具体的体现在View的onTouchEvent方法中的返回值，如果OnTouchEvent返回false，那么意味着当前View不会是该次事件的责任人，将不会对该事件持有。 20. 状态模式： 状态发生改变时，行为改变。 示例：View.onVisibilityChanged方法，就是提供了一个状态模式的实现，允许在View的visibility发生改变时，引发执行onVisibilityChanged方法中的动作。 21.策略模式 定义了一系列封装了算法、行为的对象，他们可以相互替换。 示例：Java.util.List就是定义了一个增（add）、删（remove）、改（set）、查（indexOf）策略，至于实现这个策略的ArrayList、LinkedList等类，只是在具体实现时采用了不同的算法。但因为它们策略一样，不考虑速度的情况下，使用时完全可以互相替换使用。 22.命令模式 把请求封装成一个对象发送出去，方便定制、排队、取消。示例：Handler.post后Handler.handleMessage。 模板方法 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。是基于继承的代码复用的基本模式。","categories":[{"name":"Android","slug":"Android","permalink":"http://zaijiangwangzhuan.com/categories/Android/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://zaijiangwangzhuan.com/tags/面试/"}]},{"title":"利用AccessibilityService实现免Root自动安装","slug":"2015-09-09-利用AccessibilityService实现免Root自动安装","date":"2015-09-09T08:46:00.000Z","updated":"2018-07-21T03:13:52.462Z","comments":true,"path":"2015/09/09/2015-09-09-利用AccessibilityService实现免Root自动安装/","link":"","permalink":"http://zaijiangwangzhuan.com/2015/09/09/2015-09-09-利用AccessibilityService实现免Root自动安装/","excerpt":"","text":"利用AccessibilityService实现免Root自动安装实现原理AccessibilityService运行在后台 它能够收到由系统发出的一些事件 比如焦点改变,输入内容变化,按钮被点击了等等。 并且该种服务能够通过查找text得到text对应的控件,这就可以实现我们的需求 通过对查找的控件实现点击操作 遇到的问题: 有的手机确定点不到解决方案, 反编译 360代码getRootInActiveWindow() 来 代替 event.getSource 针对不同的系统,使用TextView 和 Button 来查找是否是符合的 对于定制的系统,安装 package 不一定相同 使用不同的package 废话不多说上代码 AndroidManifest.xml 注册Service 1234567891011&lt;serviceandroid:name=&quot;.settings.AutoInstallAccessibilityService&quot;android:label=&quot;@string/setting_auto_install_acc_service_name&quot;android:permission=&quot;android.permission.BIND_ACCESSIBILITY_SERVICE&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.accessibilityservice.AccessibilityService&quot; /&gt; &lt;/intent-filter&gt; &lt;meta-dataandroid:name=&quot;android.accessibilityservice&quot;android:resource=&quot;@xml/auto_install_accessibility&quot; /&gt;&lt;/service&gt; 按照service注册时 所配置的android:resource 创建auto_install_accessibility.xml 123456789&lt;accessibility-service xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:accessibilityEventTypes=&quot;typeAllMask&quot; android:accessibilityFeedbackType=&quot;feedbackGeneric&quot; android:accessibilityFlags=&quot;&quot; android:canRetrieveWindowContent=&quot;true&quot; android:description=&quot;@string/setting_auto_install_acc_des&quot; android:notificationTimeout=&quot;100&quot; android:packageNames=&quot;com.android.packageinstaller,com.lenovo.safecenter,com.lenovo.security,com.xiaomi.gamecenter&quot;&gt;&lt;/accessibility-service&gt; 编写Service 继承AccessibilityService 实现模拟点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155/** * 免root自动装* Created by TAJ_C on 2015/9/9. */@SuppressLint(&quot;NewApi&quot;)public class AutoInstallAccessibilityService extends AccessibilityService &#123; private static HashMap&lt;String, Boolean&gt; autoInstallMap; private static final String[] INSTALL = &#123;&quot;安装&quot;, &quot;install&quot;&#125;; private static final String[] NEXT = &#123;&quot;下一步&quot;, &quot;next&quot;&#125;; private static final String[] FINISH = &#123;&quot;完成&quot;, &quot;complete&quot;&#125;; @Override public void onAccessibilityEvent(AccessibilityEvent event) &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN) &#123; try &#123; if (event == null || event.getSource() == null || getRootInActiveWindow() == null) &#123; return; &#125; if (event.getPackageName() == null || (false == event.getPackageName().equals(&quot;com.android.packageinstaller&quot;) &amp;&amp; false == event.getPackageName().equals(&quot;com.google.android.packageinstaller&quot;) &amp;&amp; false == event.getPackageName().equals(&quot;com.lenovo.safecenter&quot;) &amp;&amp; false == event.getPackageName().equals(&quot;com.lenovo.security&quot;) &amp;&amp; false == event.getPackageName().equals(&quot;com.xiaomi.gamecenter&quot;) &amp;&amp; false == event.getPackageName().equals(&quot;com.samsung.android.packageinstaller&quot;))) &#123; return; &#125; if (false == isAutoInstall(getRootInActiveWindow())) &#123; return; &#125; clickButtonByName(event.getSource(), INSTALL); clickButtonByName(event.getSource(), NEXT); clickButtonByName(getRootInActiveWindow(), FINISH); &#125; catch (Exception e) &#123; LogUtils.e(e.toString()); &#125; &#125; &#125; /** * 只针对于本应用下载的应用才进行 自动安装 */ private boolean isAutoInstall(AccessibilityNodeInfo nodeInfo) &#123; int queryFilter = DownloadManager.STATUS_SUCCESSFUL | DownloadManager.STATUS_EXTRA_UPGRADABLE | DownloadManager.STATUS_EXTRA_INSTALLED; List&lt;TaskInfo&gt; taskInfoList = DownloadHelper.getDownloadTasks( AutoInstallAccessibilityService.this, DownloadHelper.QUERY_TYPE_BY_STATUS, queryFilter); if (autoInstallMap == null) &#123; autoInstallMap = new HashMap&lt;&gt;(); &#125; for (TaskInfo taskInfo : taskInfoList) &#123; String appName = taskInfo.getAppLabel(); if (!TextUtils.isEmpty(appName) &amp;&amp; autoInstallMap != null &amp;&amp; !autoInstallMap.containsKey(appName)) &#123; autoInstallMap.put(appName, true); &#125; &#125; for (String appName : autoInstallMap.keySet()) &#123; if (!TextUtils.isEmpty(appName) &amp;&amp; nodeInfo != null) &#123; List&lt;AccessibilityNodeInfo&gt; nodeInfos = nodeInfo.findAccessibilityNodeInfosByText(appName); if (!ListUtils.isEmpty(nodeInfos)) &#123; return true; &#125; &#125; &#125; return false; &#125; @Override public void onInterrupt() &#123; &#125; /** * 模拟点击 */ private void clickButtonByName(AccessibilityNodeInfo accessibilityNodeInfo, String[] btnNames) &#123; for (String btnName : btnNames) &#123; List&lt;AccessibilityNodeInfo&gt; okNodes = accessibilityNodeInfo.findAccessibilityNodeInfosByText(btnName); if (!ListUtils.isEmpty(okNodes)) &#123; for (AccessibilityNodeInfo node : okNodes) &#123; CharSequence charSequence = node.getText(); if (TextUtils.isEmpty(charSequence) || !charSequence.toString().equals(btnName)) &#123; continue; &#125; if ((node.getClassName().equals(&quot;android.widget.Button&quot;) || node.getClassName().equals(&quot;android.widget.TextView&quot;)) &amp;&amp; node.isEnabled()) &#123; node.performAction(AccessibilityNodeInfo.ACTION_CLICK); &#125; &#125; &#125; &#125; &#125; // 检查是否开启服务 public static boolean isAccessibilitySettingsOn(Context context) &#123; int accessibilityEnabled = 0; final String service = context.getPackageName() + &quot;/&quot; + AutoInstallAccessibilityService.class.getName(); boolean accessibilityFound = false; try &#123; accessibilityEnabled = Settings.Secure.getInt(context.getApplicationContext().getContentResolver(), android.provider.Settings.Secure.ACCESSIBILITY_ENABLED); &#125; catch (Settings.SettingNotFoundException e) &#123; &#125; TextUtils.SimpleStringSplitter mStringColonSplitter = new TextUtils.SimpleStringSplitter(&apos;:&apos;); if (accessibilityEnabled == 1) &#123; String settingValue = Settings.Secure.getString(context.getApplicationContext().getContentResolver(), Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES); if (settingValue != null) &#123; TextUtils.SimpleStringSplitter splitter = mStringColonSplitter; splitter.setString(settingValue); while (splitter.hasNext()) &#123; String accessabilityService = splitter.next(); if (accessabilityService.equalsIgnoreCase(service)) &#123; return true; &#125; &#125; &#125; &#125; else &#123; // Log.v(TAG, &quot;***ACCESSIBILIY IS DISABLED***&quot;); &#125; return accessibilityFound; &#125; @Override public void onDestroy() &#123; super.onDestroy(); if (autoInstallMap != null) &#123; autoInstallMap.clear(); &#125; &#125;&#125; 完结 参考链接","categories":[{"name":"Android","slug":"Android","permalink":"http://zaijiangwangzhuan.com/categories/Android/"}],"tags":[{"name":"黑科技","slug":"黑科技","permalink":"http://zaijiangwangzhuan.com/tags/黑科技/"}]},{"title":"AndroidROM开发笔记","slug":"2014-01-05-AndroidROM开发笔记","date":"2014-01-05T08:46:00.000Z","updated":"2018-07-21T03:13:52.461Z","comments":true,"path":"2014/01/05/2014-01-05-AndroidROM开发笔记/","link":"","permalink":"http://zaijiangwangzhuan.com/2014/01/05/2014-01-05-AndroidROM开发笔记/","excerpt":"","text":"网站备份Android ROM开源的网站: 小米 CM 深度 驱动下载 android google服务包 其他如何修改系统默认字体大小修改这个默认值，可以在下面这个文件中进行修改在alps/frameworks/base/core/java/android/content/res/Configuration.java文件中如下public void setToDefaults() 这个方法中进行修改如果默认要改成特大字体，请改为1.15f，然后重新build framework.jar这个模块即可123456789public void setToDefaults() &#123; fontScale = 1.15f; //normal value is 1 mcc = mnc = 0; 注意：Settings中系统的字体大小，在/packages/apps/Settings/res/values/arrays.xml文件中的”entryvalues_font_size”这个tag中分别有定义对应的数值 Small:0.9 Normal:1.0 Large:1.1 Extra Large:1.15 所以如果要修改默认值，直接在上面那个方法中修改fontScale 为对应的数值即可(注意带上f，表示为float类型) so库缺失拷贝到相应目录 拷贝SO文件示例 12PRODUCT_COPY_FILES += \\vendor/cos/prebuilt/common/google/optional/face/lib/libfacelock_jni.so:system/lib/libfacelock_jni.so 拷贝文件夹 1234567google_system_lib_files := $(shell ls vendor/cos/prebuilt/common/google/system/lib )PRODUCT_COPY_FILES += $(foreach file, $(google_system_lib_files), \\ vendor/cos/prebuilt/common/google/system/lib/$(file):system/lib/$(file))google_option_face_vendor_files := $(shell find vendor/cos/prebuilt/common/google/optional/face/vendor -name *.bin | sed &apos;s/vendor\\/cos\\/prebuilt\\/common\\/google\\/optional\\/face\\/vendor/vendor/&apos; )PRODUCT_COPY_FILES += $(foreach file, $(google_option_face_vendor_files), \\ vendor/cos/prebuilt/common/google/optional/face/$(file):system/$(file))","categories":[{"name":"Android","slug":"Android","permalink":"http://zaijiangwangzhuan.com/categories/Android/"}],"tags":[{"name":"ROM","slug":"ROM","permalink":"http://zaijiangwangzhuan.com/tags/ROM/"}]},{"title":"Android源码打包","slug":"2013-12-18-Android源码打包","date":"2013-12-18T08:46:00.000Z","updated":"2018-07-21T03:13:52.460Z","comments":true,"path":"2013/12/18/2013-12-18-Android源码打包/","link":"","permalink":"http://zaijiangwangzhuan.com/2013/12/18/2013-12-18-Android源码打包/","excerpt":"","text":"Android源码打包window xp 系统准备 搭建java 环境、 下载签名工具：Auto-sign 下载压缩工具：7zip拆包在该文档“编辑源码”那块已经说明使用“make -jn otapackage”该编译命令生成更加通用的zip格式的 ROM包。拆包很简单，直接解压就行。 更改 下面是解压后文件夹内容： boot.img文件，这是系统的镜像，包括Linux内核以及系统启动的一些基本文件。META-INF目录，这里主要有系统更新脚本，路径是：META-INF/com/google/android/updater-script system/app目录，系统自带的应用程序都放在这个目录下，比如日历、联系人、gmail等，你可以把自己的apk文件放在该目录下，这样就可以在刷ROM的时候直接安装上 system/bin目录，系统命令，可以通过adb shell登录后执行，比如top system/etc目录，类似linux的/etc目录 system/font目录，字体 system/framework目录，android框架，是java实现，在dalvik虚拟机下支持用户java开发的框架 system/lib目录，android本地共享库，都是so文件，是c、c++编译的本地共享库 system/media目录，一些媒体文件，比如bootanimation.zip，压缩包里面是一些png图，用于开机动画，替代这些可以改变开机画面，audio目录下是一些声音文件，用于铃声和通知等 打包 在META-INF 相同路径下，选中全部内容后右击用7zip打包该目录成为一个zip文件，并改名为update.zip 签名 将完成的update.zip 放入Auto-sign的目录中，运行Sign.bat 在根目录就会自动生存update_signed.zip。如果不签名android是不认的，recovery的时候会在校验ROM包的时候报错。 升级将update_signed.zip copy 至sdcard 根目录下，进入recovery 模式，选择update_signed.zip 升级即可。 Linux 系统准备 搭建java 环境、 签名工具：需要signapk.jar testkey.x509.pem testkey.pk8三个文件。 三个文件是由Android整个源代码编译完后会自动生成,路径如下: signapk.jar位于./out/host/linux-x86/framework/目录 testkey.x509.pem，testkey.pk8位于./build/target/product/security/目录 更改 同window xp系统下的更改。 打包 在META-INF 相同路径下输入linux 指令 zip -r update.zip ./* 签名 将签名工具所需3个文件copy到与update.zip 同一路径下，在linux下执行签名指令，生成update_sign.zip 文件包，此即为升级包。签名指令:1java -jar signapk.jar -w testkey.x509.pem testkey.pk8 update.zip update_sign.zip 升级将update_signed.zip copy 至sdcard 根目录下，进入recovery 模式，选择update_sign.zip 升级即可。 增量更新包打包步骤如下: 建立2个文件夹目录：mkdir ./META-INF/com/google/android/mkdir ./system/app注意：记得更改这2个目录及其子目录的权限，以免出现无法copy 文件的问题。 在android/目录下添加2个文件，分别是update-binary 和updater-script。 update-binary 在 /out/target/product/dkb/system/bin/ 目录下的updater 文件，直接将updater copy到 /META-INF/com/google/android/ ，并改名为update-binary 即可。 updater-script 脚本文件需要自己编写(具体脚本语法请参考相关文档)，根据具体升级的内容的不同，编写的脚本也是不一样的。下面贴出升级系统app的脚本。123456789101112131415ui_print(&quot;--------------------------------&quot;);ui_print(&quot;Mounting filesystem...&quot;);ui_print(&quot;--------------------------------&quot;);mount(&quot;ext4&quot;, &quot;EMMC&quot;, &quot;/dev/block/platform/msm_sdcc.1/by-name/system&quot;, &quot;/system&quot;);show_progress(0.1, 0);set_progress(1.000000);package_extract_dir(&quot;system/app&quot;,&quot;/system/app&quot;);show_progress(0.9, 5);ui_print(&quot;Updating System Finish....&quot;);unmount(&quot;/system&quot;);ui_print(&quot;--------------------------------&quot;);ui_print(&quot; Update success! &quot;);ui_print(&quot;--------------------------------&quot;); 将你需要升级的apk文件copy 到./system/app/ 目录中。 将META-INF 和 system 一起压缩成update.zip 包。 在META-INF 相同路径下输入linux 指令1$ zip -r update.zip ./* 指令执行完成后，生成update.zip 压缩包 将update.zip 签名。同上一章节ROM 在linux下打包签名 将update_sign.zip copy 至sdcard 根目录下，进入recovery 模式，选择update_sign.zip 升级即可。 添加应用到Android 源码 在和系统相同版本的SDK目录下开发自己的android应用. 把开发的android工程放到源码的packages/apps/目录下 在自己应用工程目录下添加Android.mk文件下面是用SnailMusic 为例, Android.mk内容如下：123456789101112131415161718192021222324252627282930LOCAL_PATH:= $(call my-dir)include $(CLEAR_VARS)#表示目标模式LOCAL_MODULE_TAGS := optional#引用了两个第三方jar包，定义jar库的引用名，可以任意取值；LOCAL_STATIC_JAVA_LIBRARIES := libhttpclient\\ Androidsupport# Build all java files in the java subdirectoryLOCAL_SRC_FILES := $(call all-java-files-under, src)LOCAL_SDK_VERSION := current# 生成apk的名字LOCAL_PACKAGE_NAME := SnailMusic#编译一个需要platform key签名的APKLOCAL_CERTIFICATE := platform＃所包含的库include $(BUILD_PACKAGE)######################################################include $(CLEAR_VARS)# 指定prebuiltjar库的规则，格式：引用名:jar文件路径LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES := libhttpclient:libs/commons-httpclient-3.1.jar\\ androidsupport:libs/android-support-v4.jarLOCAL_MODULE_TAGS := optionalinclude $(BUILD_MULTI_PREBUILT)# Use the folloing include to make our test apk.include $(call all-makefiles-under,$(LOCAL_PATH)) 4 进入到&lt;android_src&gt;/build/target/product目录中，修改core.mk, sdk.mk文件，把自已的项目加入编译行列中。5．最后进入到&lt;android_src&gt;源码根目录，全局编译","categories":[{"name":"Android","slug":"Android","permalink":"http://zaijiangwangzhuan.com/categories/Android/"}],"tags":[{"name":"ROM","slug":"ROM","permalink":"http://zaijiangwangzhuan.com/tags/ROM/"}]},{"title":"Android源码编译与刷机","slug":"2013-12-16-Android源码编译与刷机","date":"2013-12-16T08:46:00.000Z","updated":"2018-07-21T03:13:52.459Z","comments":true,"path":"2013/12/16/2013-12-16-Android源码编译与刷机/","link":"","permalink":"http://zaijiangwangzhuan.com/2013/12/16/2013-12-16-Android源码编译与刷机/","excerpt":"","text":"content{:toc} 源码编译下载源码source.android.com 下载驱动 https://developers.google.com/android/nexus/drivers 下载所需对应的机型的驱动二进制文件 将下载好的驱动文件解压到源码根目录下。 sh 文件名.sh 进行安装。 编译源码 设置编译环境：$ source build/envsetup.sh 选择编译对应的机型：$ lunch代号对应的机型在下驱动文件时就能看到，例如 Nexus 4对应的代号就是mako，如果要编译该机型系统，选择11即可。 编译系统： make –jn，n代表线程数，根据自己电脑的情况选择，一般双核CPU选择4个线程编译；该命令输出img格式的系统刷机文件。 make -jn otapackage该命令生成更加通用的zip格式，更加通用，比如第三方的recovery也能使用。 编译完成后，刷机文件一律生成于源码根目录/out/target/product/对应的设备代号 刷机 编译fastboot和adb工具：$ make fastboot adb 手机进入fastboot模式，一般是关机后，按住音量键减+电源键进入。 输入命令，查看设备是否被识别：./out/host/linux-x86/bin/fastboot devices 解锁设备：$ fastboot oem unlock 刷入ROM： 一次全部刷入，如下:1$ fastboot flashall -w 一般情况下这一步会出现以下错误提示：neither -p product specified nor ANDROID_PRODUCT_OUT set；原因是没有设置rom的位置，解决方法要么使用-p参数，后面跟着rom的位置；或者配置环境变量ANDROID_PRODUCT_OUT，过程如下：输入sudo gedit /etc/profile，在尾部添加export ANDROID_PRODUCT_OUT=源码目录/out/target/product/设备代号，保存并退出然后输入source /etc/profile使刚设置的环境变量立即生效。 单独刷boot,recovery,system三个img文件，如下:12345$ sudo ./fastboot flash bootloader /out/target/product/mako/boot.img$sudo ./fastboot reboot-bootloader$ sudo ./fastboot flash recovery out/target/product/mako/recovery.img$sudo ./fastboot reboot-bootloader$ sudo ./fastboot flash system -w out/target/product/mako/system.img","categories":[{"name":"Android","slug":"Android","permalink":"http://zaijiangwangzhuan.com/categories/Android/"}],"tags":[{"name":"ROM","slug":"ROM","permalink":"http://zaijiangwangzhuan.com/tags/ROM/"}]}]}