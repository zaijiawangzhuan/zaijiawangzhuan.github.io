<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>在家网赚</title>
  
  <subtitle>在家能赚钱</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zaijiangwangzhuan.com/"/>
  <updated>2018-11-13T12:49:55.783Z</updated>
  <id>http://zaijiangwangzhuan.com/</id>
  
  <author>
    <name>微信号:caishen2048</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>恒大金融</title>
    <link href="http://zaijiangwangzhuan.com/2018/11/20/fenghuang/"/>
    <id>http://zaijiangwangzhuan.com/2018/11/20/fenghuang/</id>
    <published>2018-11-20T05:48:05.000Z</published>
    <updated>2018-11-13T12:49:55.783Z</updated>
    
    <content type="html"><![CDATA[<h4 id="恒大金服"><a href="#恒大金服" class="headerlink" title="恒大金服"></a>恒大金服</h4><h4 id="任务号-2004"><a href="#任务号-2004" class="headerlink" title="任务号: 2004"></a>任务号: 2004</h4><h4 id="佣金30元-平台送-20-50-100代金券-投资收益"><a href="#佣金30元-平台送-20-50-100代金券-投资收益" class="headerlink" title="佣金30元 + 平台送 20,50,100代金券 + 投资收益"></a>佣金30元 + 平台送 20,50,100代金券 + 投资收益</h4><p>世界500强恒大集团官方白平台.绝对安全靠谱</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li>必须通过活动链接</li><li>活动在2017年08月31日结束</li></ol><h3 id="任务流程"><a href="#任务流程" class="headerlink" title="任务流程"></a>任务流程</h3><ol><li><p>点击 “开始任务” 跳转到浏览器注册下载恒大金服App登陆</p></li><li><p>点击理财一选择新人专享或其他接近180天的标，按提示实名绑卡 投资100元，记得勾选20元现金券，实际支付80元 到期可提<br>现105元.</p></li></ol><h3 id="任务提交内容-点击这里"><a href="#任务提交内容-点击这里" class="headerlink" title="任务提交内容: 点击这里"></a>任务提交内容: <a href="http://zaijiawangzhuan.mikecrm.com/gDxuSZt" target="_blank" rel="noopener">点击这里</a></h3><ol><li>注册名填写 注册手机号码</li><li>投资成功的截图或者交易详倩截图</li></ol><p><a href="https://promotion.hdfax.com/mobile/invitation/register/new?inviteCode=a5b8a96375224315b5b597f8c83c7e3a&amp;marketChannel=ZF_promotion0901&amp;inviter=%E9%99%88%E5%B9%B3" target="_blank" rel="noopener">.</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;恒大金服&quot;&gt;&lt;a href=&quot;#恒大金服&quot; class=&quot;headerlink&quot; title=&quot;恒大金服&quot;&gt;&lt;/a&gt;恒大金服&lt;/h4&gt;&lt;h4 id=&quot;任务号-2004&quot;&gt;&lt;a href=&quot;#任务号-2004&quot; class=&quot;headerlink&quot; title=&quot;任
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://zaijiangwangzhuan.com/2018/11/13/test/"/>
    <id>http://zaijiangwangzhuan.com/2018/11/13/test/</id>
    <published>2018-11-13T12:45:23.377Z</published>
    <updated>2018-11-13T12:45:23.377Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://zaijiangwangzhuan.com/2018/11/13/test2/"/>
    <id>http://zaijiangwangzhuan.com/2018/11/13/test2/</id>
    <published>2018-11-12T16:00:00.000Z</published>
    <updated>2018-11-13T12:46:21.038Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://zaijiangwangzhuan.com/2018/11/08/hello-world/"/>
    <id>http://zaijiangwangzhuan.com/2018/11/08/hello-world/</id>
    <published>2018-11-08T11:45:20.910Z</published>
    <updated>2017-10-28T00:39:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>shenqian</title>
    <link href="http://zaijiangwangzhuan.com/2018/09/20/shenqian/"/>
    <id>http://zaijiangwangzhuan.com/2018/09/20/shenqian/</id>
    <published>2018-09-20T05:48:05.000Z</published>
    <updated>2018-09-20T06:04:41.965Z</updated>
    
    <content type="html"><![CDATA[<p><img src="test.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;test.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android开源库整理</title>
    <link href="http://zaijiangwangzhuan.com/2017/08/30/2017-08-30-Android%E5%BC%80%E6%BA%90%E5%BA%93%E6%95%B4%E7%90%86/"/>
    <id>http://zaijiangwangzhuan.com/2017/08/30/2017-08-30-Android开源库整理/</id>
    <published>2017-08-30T08:00:00.000Z</published>
    <updated>2018-07-21T03:13:52.468Z</updated>
    
    <content type="html"><![CDATA[<ul><li>content<br>{:toc}</li></ul><h3 id="图片加载库"><a href="#图片加载库" class="headerlink" title="图片加载库"></a>图片加载库</h3><blockquote><p>(解决网络, 文件, res, assets等图片的获取, 解析, 展示, 缓存等需求…)</p></blockquote><table><thead><tr><th>名称</th><th>概要</th><th>详情</th></tr></thead><tbody><tr><td><a href="https://github.com/square/picasso" target="_blank" rel="noopener">*Picasso</a></td><td>Github大神推荐的强大的图片下载和缓存库</td><td>Square 开源的项目,主导者是 <a href="https://github.com/JakeWharton" target="_blank" rel="noopener">JakeWharton</a>.</td></tr><tr><td><a href="https://github.com/bumptech/glide" target="_blank" rel="noopener">*Glide</a></td><td>Google推荐的图片加载和缓存的库</td><td>专注于平滑滚动时的流畅加载, Google开源项目, 2014年Google I/O 上被推荐</td></tr><tr><td><a href="https://github.com/facebook/fresco" target="_blank" rel="noopener">*Fresco</a></td><td>Facebook推荐的的Android图片加载库</td><td>自动管理图片的加载和图片的缓存.Facebook 在2015年上半年开源的图片加载库</td></tr><tr><td><a href="https://github.com/nostra13/Android-Universal-Image-Loader" target="_blank" rel="noopener">*Android-Universal-Image-Loader</a></td><td>早期广泛使用的开源图片加载库</td><td>强大又灵活的Android库, 用于加载,缓存,显示图片.</td></tr><tr><td><a href="https://github.com/mcxiaoke/android-volley" target="_blank" rel="noopener">Volley</a></td><td>2013年Google I/O推荐的网络通讯框架</td><td>使用volley加载网络图片，主要用到其中的ImageLoader, NetworkImageView类, 注意它不仅仅是个图片加载库.</td></tr><tr><td><a href="https://github.com/etao-open-source/cube-sdk" target="_blank" rel="noopener">Cube-sdk</a></td><td>轻量级的Android开发框架</td><td>高效方便地加载网络图片, 更简易地处理网络API请求</td></tr></tbody></table><h3 id="图片处理库"><a href="#图片处理库" class="headerlink" title="图片处理库"></a>图片处理库</h3><blockquote><p>(解决图片缩放, 裁剪, 平移, 旋转等需求)</p></blockquote><table><thead><tr><th>名称</th><th>概要</th><th>详情</th></tr></thead><tbody><tr><td><a href="https://github.com/boycy815/PinchImageView" target="_blank" rel="noopener">PinchImageView</a></td><td>国人写的, 可能是体验最好的图片手势控件</td><td>支持双击放大，双击缩小,超出边界会回弹, 滑动惯性，不同分辨率无缝切换，可与ViewPager结合使用。 star:360</td></tr><tr><td><a href="https://github.com/alexvasilkov/GestureViews" target="_blank" rel="noopener">GestureViews</a></td><td>包含ImageView的自定义FrameLayout</td><td>项目目的是让图片的查看尽可能流畅平滑, 让开发者更加方便地集成到自己的应用中, 支持手势控制和动画 star:582</td></tr><tr><td><a href="https://github.com/chrisbanes/PhotoView" target="_blank" rel="noopener">*PhotoView</a></td><td>致力于帮助开发者高效的创建可缩放的ImageView</td><td>重写ImageView的实现, 支持多点触摸的图片缩放 star:4705</td></tr><tr><td><a href="https://github.com/davemorrissey/subsampling-scale-image-view" target="_blank" rel="noopener">subsampling-scale-image-view</a></td><td>一个Android自定义图片视图, 专为图片画廊设计</td><td>丰富的配置选项, 更方便的实现图片的手势缩放, 旋转, 平移. 无损展示大图, 完美的地嵌入画廊, 地图等.可显示大图(地图, 建筑设计图)等而不造成OutOfMemoryErrors(OOM内存溢出异常) star:1137</td></tr><tr><td><a href="https://github.com/MikeOrtiz/TouchImageView" target="_blank" rel="noopener">TouchImageView</a></td><td>一个ImageView的拓展类</td><td>支持ImageView所有功能, 添加了平移, 缩放, 拖拽, 滑动, 双击缩放等动画.star:1252</td></tr><tr><td><a href="https://github.com/sephiroth74/ImageViewZoom" target="_blank" rel="noopener">ImageViewZoom</a></td><td>自定义ImageView控件</td><td>一个可以缩放, 平移的自定义ImageView控件. star:1080</td></tr></tbody></table><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h3 id="网络加载框架"><a href="#网络加载框架" class="headerlink" title="网络加载框架"></a>网络加载框架</h3><blockquote><p>解决各种协议(GET, POST, PUT, HEAD, DETELE…)的网络数据的获取及请求, 支持异步,同步请求; 文件多线程下载断点续传, 上传; 请求自动重试, gzip压缩, Cookies自动解析并持久化. 数据的缓存. 目标是让网络请求更方便, 简介, 高效, 稳定.</p></blockquote><table><thead><tr><th>名称</th><th>概要</th><th>详情</th></tr></thead><tbody><tr><td><a href="http://square.github.io/retrofit/" target="_blank" rel="noopener">*Retrofit2.0</a></td><td>以接口/注解的形式定义请求和响应</td><td>Square 开源的项目. 是一套RESTful架构的Android(Java)客户端实现，基于注解，提供JSON to POJO(Plain Ordinary Java Object,简单Java对象)，POJO to JSON，网络请求(POST，GET,PUT，DELETE等)封装。 Jake Wharton大神力荐. 本身的网络核心可以替换. 如Apache HTTP client, URL connection, OKHttp等, 数据解析核心也可以替换如Gson, Jackson, fastjson, xStream等. 力求用最少的代码, 实现最强大的功能. <a href="http://square.github.io/retrofit/" target="_blank" rel="noopener">官方主页</a></td></tr><tr><td><a href="https://github.com/square/okhttp" target="_blank" rel="noopener">*okhttp</a></td><td>一个为安卓和java应用诞生的Http+SPDY的网络处理库</td><td>square开源项目. a. 支持HTTP, HTTPS, HTTP/2.0, and SPDY协议 b. 自动缓存数据, 节省流量, c.内部自动GZIP压缩内容.</td></tr><tr><td><a href="https://github.com/loopj/android-async-http" target="_blank" rel="noopener">android-async-http</a></td><td>一个异步的AndroidHttp库</td><td>比较经典的网络请求库, 基于Apache的HttpClient库实现, 但是由于AndroidM(6.0)去除了对HttpClient相关API, 意味着google不再推荐使用.</td></tr><tr><td><a href="https://github.com/mcxiaoke/android-volley" target="_blank" rel="noopener">Volley</a></td><td>一个能让Android的网络请求更简单快捷的Http库</td><td><a href="https://android.googlesource.com/platform/frameworks/volley" target="_blank" rel="noopener">官方地址, 需翻墙</a> Volley集成了AsyncHttpClient和Universal-Image-Loader的优点，既可以像AsyncHttpClient一样非常简单地进行HTTP通信，也可以像Universal-Image-Loader一样轻松加载网络上的图片。但是对大数据量的网络操作如文件的下载支持较差</td></tr></tbody></table><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><table><thead><tr><th>名称</th><th>概要</th><th>详情</th></tr></thead><tbody><tr><td><a href="https://github.com/airbnb/lottie-android" target="_blank" rel="noopener">Lottie</a></td><td>Airbnb</td></tr></tbody></table><table><thead><tr><th>名称</th><th>概要</th><th>详情</th></tr></thead><tbody><tr><td><a href="https://code.google.com/archive/p/gifview2/downloads" target="_blank" rel="noopener">gifview </a></td><td>Airbnb</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;content&lt;br&gt;{:toc}&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;图片加载库&quot;&gt;&lt;a href=&quot;#图片加载库&quot; class=&quot;headerlink&quot; title=&quot;图片加载库&quot;&gt;&lt;/a&gt;图片加载库&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;(解决网络, 
      
    
    </summary>
    
      <category term="Android" scheme="http://zaijiangwangzhuan.com/categories/Android/"/>
    
    
      <category term="第三方" scheme="http://zaijiangwangzhuan.com/tags/%E7%AC%AC%E4%B8%89%E6%96%B9/"/>
    
  </entry>
  
  <entry>
    <title>Android免商店应用架构</title>
    <link href="http://zaijiangwangzhuan.com/2017/08/28/2017-08-28-Android%E5%85%8D%E5%95%86%E5%BA%97%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84/"/>
    <id>http://zaijiangwangzhuan.com/2017/08/28/2017-08-28-Android免商店应用架构/</id>
    <published>2017-08-28T08:00:00.000Z</published>
    <updated>2018-07-21T03:13:52.467Z</updated>
    
    <content type="html"><![CDATA[<ul><li>content<br>{:toc}</li></ul><h2 id="Android免商店应用架构"><a href="#Android免商店应用架构" class="headerlink" title="Android免商店应用架构"></a>Android免商店应用架构</h2><h3 id="分包"><a href="#分包" class="headerlink" title="分包"></a>分包</h3><p>大体使用MVC 架构，按照基础支持功能和业务功能 来分包</p><p>第一层 com.company(公司域名) + app(应用程序名)</p><p>第二层 各模块包名, 基础支持功能+ 业务模块功能<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">com.company.app</span><br><span class="line">    |--  common</span><br><span class="line">        |-- config           配置</span><br><span class="line">        |-- AppConstants.java  存放应用程序的根配置，比如版本，目标配置等等</span><br><span class="line">        |-- widget</span><br><span class="line">        |-- model  公共model</span><br><span class="line">        |-- adapter 公共的adpter</span><br><span class="line">    |-- base</span><br><span class="line">        |-- BaseApplication.java</span><br><span class="line">        |-- BaseActivity.java 定义一些基础 Activity 和 抽象方法</span><br><span class="line">        |-- BaseFragment.java</span><br><span class="line">    |-- db    数据库</span><br><span class="line">    |-- network  网络请求</span><br><span class="line">    |-- home 首页模块</span><br><span class="line">        |-- model</span><br><span class="line">        |-- adapter</span><br><span class="line">        |-- HomeFragment.java</span><br><span class="line">    |-- ...</span><br><span class="line">    |-- personal 个人中心模块</span><br><span class="line">        |-- model</span><br><span class="line">        |-- adapter</span><br><span class="line">        |-- PersonalFragment.java</span><br><span class="line">    |-- support 支持模块，如升级 反馈 分享</span><br><span class="line">    |-- utils  工具类库与业务无关的公共方法</span><br><span class="line">    |-- MainActivity.java</span><br></pre></td></tr></table></figure></p><h3 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h3><ul><li>注解:  ButterKnife</li><li>网络:  Volley</li><li>图片加载:   fresco</li><li>通信:  otto</li><li>解析Json:  fastjson</li><li>解析网页: jsoup</li><li>生成GetSet： Lombok</li><li>数据库: OrmLite</li><li>检查内存溢出: leakcanary</li><li>异步操作: RXJava</li></ul><h3 id="工具类第三方"><a href="#工具类第三方" class="headerlink" title="工具类第三方"></a>工具类第三方</h3><ul><li>统计:  Umeng</li><li>错误: Testing</li><li>人脸识别: face++</li><li>地图:  高德api</li><li>推送: 个推</li><li>二维码识别: Zbar</li></ul><h3 id="View-相关第三方"><a href="#View-相关第三方" class="headerlink" title="View 相关第三方"></a>View 相关第三方</h3><ul><li>动画兼容:     nineoldandroids</li><li>底部弹出菜单:     BottomSheet</li><li>List多个布局 : MergeAdapter</li><li>侧滑退出: swipebacklayout</li><li>图片处理: simplecropimage</li><li>带指示器的Viewpage: viewpagerindicator</li><li>列表项隐藏显示: slideexpandable</li><li>下拉刷新库: android-Ultra-Pull-To-Refresh</li><li>高斯模糊:  <a href="https://github.com/Commit451/NativeStackBlur" target="_blank" rel="noopener">NativeStackBlur</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;content&lt;br&gt;{:toc}&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Android免商店应用架构&quot;&gt;&lt;a href=&quot;#Android免商店应用架构&quot; class=&quot;headerlink&quot; title=&quot;Android免商店应用架构&quot;&gt;&lt;/a&gt;Androi
      
    
    </summary>
    
      <category term="Android" scheme="http://zaijiangwangzhuan.com/categories/Android/"/>
    
    
      <category term="架构" scheme="http://zaijiangwangzhuan.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Android博客精选</title>
    <link href="http://zaijiangwangzhuan.com/2017/08/09/2017-08-29-Android%E5%8D%9A%E5%AE%A2%E7%B2%BE%E9%80%89/"/>
    <id>http://zaijiangwangzhuan.com/2017/08/09/2017-08-29-Android博客精选/</id>
    <published>2017-08-09T08:00:00.000Z</published>
    <updated>2018-07-21T03:13:52.468Z</updated>
    
    <content type="html"><![CDATA[<ul><li>content<br>{:toc}</li></ul><h3 id="官方"><a href="#官方" class="headerlink" title="官方"></a>官方</h3><p><a href="https://github.com/kesenhoo/android-training-course-in-chinese" target="_blank" rel="noopener">Android官方培训课程中文版</a></p><h3 id="插件化"><a href="#插件化" class="headerlink" title="插件化"></a>插件化</h3><p><a href="http://www.jianshu.com/p/c36c9e0ca3fe" target="_blank" rel="noopener">Android热修复实践应用–AndFix</a></p><p><a href="http://blog.brucefeng.info/post/tech-leader-routine?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" target="_blank" rel="noopener">技术管理的路</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;content&lt;br&gt;{:toc}&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;官方&quot;&gt;&lt;a href=&quot;#官方&quot; class=&quot;headerlink&quot; title=&quot;官方&quot;&gt;&lt;/a&gt;官方&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/kese
      
    
    </summary>
    
      <category term="Android" scheme="http://zaijiangwangzhuan.com/categories/Android/"/>
    
    
      <category term="学习" scheme="http://zaijiangwangzhuan.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Android开发工具秘籍</title>
    <link href="http://zaijiangwangzhuan.com/2017/08/02/2017-08-02-Android%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%A7%98%E7%B1%8D/"/>
    <id>http://zaijiangwangzhuan.com/2017/08/02/2017-08-02-Android开发工具秘籍/</id>
    <published>2017-08-02T08:00:00.000Z</published>
    <updated>2018-07-21T03:13:52.466Z</updated>
    
    <content type="html"><![CDATA[<ul><li>content<br>{:toc}</li></ul><h3 id="1-无线调试运行"><a href="#1-无线调试运行" class="headerlink" title="1.无线调试运行"></a>1.无线调试运行</h3><blockquote><p>还在为在使用真机测试时，缺乏数据线而发愁吗？</p><p>还为每次用数据线连接真机测试时，都得抽拔抽拔烦不胜烦</p></blockquote><p>神器来了,Android ADB WIFI 插件 支持 Intellij / Android Studio ,这个是开源项目 源码地址 <a href="https://github.com/pedrovgs/AndroidWiFiADB" target="_blank" rel="noopener">https://github.com/pedrovgs/AndroidWiFiADB</a></p><ul><li>如何安装</li></ul><p>Intellij / Android Studio: Preferences/Settings-&gt;Plugins-&gt;Browse Repositories-&gt;搜索Android ADB WIFI</p><ul><li>如何使用</li></ul><ol><li>将调试手机通过USB 连接上电脑.</li><li>点击Intellij / Android Studio 刚安装的 Android ADB WIFI 按钮</li><li>此时会出现 “Device *** connected” 提示</li></ol><p>Ok！！！下面拔掉你的数据线，运行APP看看效果。</p><p>当然 如果手机root了，可以在应用市场搜索 wifi adb 下载安装</p><h3 id="2-显示当前Acitivity"><a href="#2-显示当前Acitivity" class="headerlink" title="2.显示当前Acitivity"></a>2.显示当前Acitivity</h3><blockquote><p>有一天老板要你把应用某个界面的文字放大一点 位置移动一下，然这个模块又不是你做的，    是不是一脸闷 怎么快速定位当前界面的Activity呢</p></blockquote><p>神器来了， 显示当前顶端的Activity，快速定位到当前界面。 链接地址:<a href="https://github.com/fashare2015/ActivityTracker" target="_blank" rel="noopener">https://github.com/fashare2015/ActivityTracker</a></p><h5 id="亦可通过下方cmd-命令来显示-推荐有逼格"><a href="#亦可通过下方cmd-命令来显示-推荐有逼格" class="headerlink" title="亦可通过下方cmd 命令来显示 推荐有逼格"></a>亦可通过下方cmd 命令来显示 推荐有逼格</h5><ul><li>查看当前Activity ：adb shell “dumpsys window w &#124; grep name=”</li><li>查看当前栈顶的Activity ：adb shell “dumpsys activity &#124; grep  mFocusedActivity”</li><li>查看当前栈顶的Activity的Fragment ：adb shell dumpsys activity your.package.name</li></ul><h3 id="3-开发助手-——-方便切换开发者配置"><a href="#3-开发助手-——-方便切换开发者配置" class="headerlink" title="3. 开发助手 —— 方便切换开发者配置"></a>3. 开发助手 —— 方便切换开发者配置</h3><p>Trinea 大神佳作，在此不过多介绍，详情请看：</p><p><a href="http://zhushou.360.cn/detail/index/soft_id/3644614" target="_blank" rel="noopener">Android 应用开发调试利器——开发助手，数十倍效率提升</a></p><h3 id="4-电脑端更改Hosts"><a href="#4-电脑端更改Hosts" class="headerlink" title="4.电脑端更改Hosts"></a>4.电脑端更改Hosts</h3><blockquote><p>有时候需要更换hosts 来实现内外网切换</p></blockquote><p>SwitchHosts! 是一个管理、切换多个 hosts 方案的工具。它是一个免费开源的软件<br>下载地址: <a href="http://www.xiazaiba.com/html/23970.html" target="_blank" rel="noopener">http://www.xiazaiba.com/html/23970.html</a></p><h3 id="5-抓包工具"><a href="#5-抓包工具" class="headerlink" title="5.抓包工具"></a>5.抓包工具</h3><blockquote><p>有一天 测试部门过来说 这个界面某个数据有问题, 你想看一下 服务器传过来的数据是咋样的? 还在通过调试方法看log 得到</p></blockquote><p>Charles 在做移动开发时，我们为了调试与服务器端的网络通讯协议，常常需要截取网络封包来分析。支持MAC和Windows</p><h4 id="划重点-charles和-上面的switchHosts-一起使用可以实现手机非root-切换hosts"><a href="#划重点-charles和-上面的switchHosts-一起使用可以实现手机非root-切换hosts" class="headerlink" title="划重点: charles和 上面的switchHosts 一起使用可以实现手机非root 切换hosts"></a>划重点: charles和 上面的switchHosts 一起使用可以实现手机非root 切换hosts</h4><h3 id="6-打包工具"><a href="#6-打包工具" class="headerlink" title="6.打包工具"></a>6.打包工具</h3><blockquote><p>我们在开发Android时，经常会遇到的一个问题就是多渠道打包，这个是很烦躁的问题，因为如果使用AndroidStudio中的productFlavors去进行生成多渠道包，这个是非常耗时的。</p></blockquote><p>美团之前提供了一个创建以渠道号为名的空文件夹塞到apk中, 现在这种方法在7.0里面失效了 现在美团又提供了一个写id的方法</p><p><a href="https://tech.meituan.com/android-apk-v2-signature-scheme.html" target="_blank" rel="noopener">美团官方技术博客</a></p><p><a href="https://github.com/Meituan-Dianping/walle" target="_blank" rel="noopener">美团打包github</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;content&lt;br&gt;{:toc}&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-无线调试运行&quot;&gt;&lt;a href=&quot;#1-无线调试运行&quot; class=&quot;headerlink&quot; title=&quot;1.无线调试运行&quot;&gt;&lt;/a&gt;1.无线调试运行&lt;/h3&gt;&lt;blockquote
      
    
    </summary>
    
      <category term="Android" scheme="http://zaijiangwangzhuan.com/categories/Android/"/>
    
    
      <category term="开发工具" scheme="http://zaijiangwangzhuan.com/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Android动态加载皮肤</title>
    <link href="http://zaijiangwangzhuan.com/2017/07/18/2018-07-18-Android%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E7%9A%AE%E8%82%A4/"/>
    <id>http://zaijiangwangzhuan.com/2017/07/18/2018-07-18-Android动态加载皮肤/</id>
    <published>2017-07-18T08:00:00.000Z</published>
    <updated>2018-07-21T03:13:52.469Z</updated>
    
    <content type="html"><![CDATA[<ul><li>content<br>{:toc}</li></ul><h2 id="Android免商店动态加载皮肤"><a href="#Android免商店动态加载皮肤" class="headerlink" title="Android免商店动态加载皮肤"></a>Android免商店动态加载皮肤</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>应用提供皮肤功能，可以作为应用推广和用户个性化的方案。免商店提供皮肤动态切换和加载，极大的提升了用户使用体验，也为新品推广提供一种途径。</p><p>Android内使用皮肤即主题有几种方式：</p><ul><li>自带Theme及Style</li><li>使用已安装皮肤应用的Theme等资源</li><li>动态加载皮肤包apk<br>由于第一种是使用应用内资源，需要每次应用更新才能使用新主题等资源，不能随时动态加载，并不方便灵活。而第二种需要安装皮肤包apk，对用户使用感受影响较大，故也不考虑。<br>免商店选择了第三种动态加载皮肤包，这种方式灵活且对用户透明，缺点是开发周期较长。对于需要不定期推广和低用户感知的免商店来说，第三种方式更好。</li></ul><h3 id="动态加载原理"><a href="#动态加载原理" class="headerlink" title="动态加载原理"></a>动态加载原理</h3><p>  在Android中，所有的资源都是基于包的。资源以id进行标识，在同一个应用中，每个资源都有唯一标识。每个资源都可以通过Context对象的方法getRsources获取到其绑定的资源对象，然后，就可以使用Resources的getXXX方法获取字符串、颜色、dimension、图片等。</p><p>  而Resources类也是通过AssetManager类来访问那些被编译过的应用程序资源文件的，不过在访问之前，它会先根据资源ID查找得到对应的资源文件名。需要注意的是，AssetManager可以通过无参实例化并反射调用addAssetPath方法，该方法用来添加assets的路径，这个路径就是我们皮肤包的路径。</p><p>至此，皮肤包的资源调用就完成了。</p><p>以下是参考代码范例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//获取AssetManager</span><br><span class="line">private AssetManager createAssetManager(String dexPath) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        AssetManager assetManager = AssetManager.class.newInstance();</span><br><span class="line">        Method addAssetPath = assetManager.getClass().getMethod(&quot;addAssetPath&quot;, String.class);</span><br><span class="line">        addAssetPath.invoke(assetManager, dexPath);</span><br><span class="line">        return assetManager;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//获取皮肤包的Resources</span><br><span class="line">private Resources createResources(AssetManager assetManager) &#123;</span><br><span class="line">    Resources superRes = mContext.getResources();</span><br><span class="line">    return new Resources(assetManager, superRes.getDisplayMetrics(), superRes.getConfiguration());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>皮肤包可通过与免商店约定资源名来获取资源。通过调用皮肤包的Resource对象内getIdentifier方法，传入约定的资源名，获取资源ID，再通过调用getXXX获取资源。<br>以下是参考代码范例，本例返回了一个Drawable对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int resId = resources.getIdentifier(resName, null, null);</span><br><span class="line">if (resId &gt; 0) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        return skinPluginPackage.resources.getDrawable(resId);</span><br><span class="line">    &#125; catch (OutOfMemoryError e) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="开发说明"><a href="#开发说明" class="headerlink" title="开发说明"></a>开发说明</h3><h5 id="1-皮肤模块初始化"><a href="#1-皮肤模块初始化" class="headerlink" title="1. 皮肤模块初始化"></a>1. 皮肤模块初始化</h5><p> 皮肤模块在MainActivity启动时进行了加载，并由图中工具类SystemConfigUtil获取配置在后端的皮肤信息，执行下载皮肤和加载过程。</p><h5 id="2-皮肤包加载"><a href="#2-皮肤包加载" class="headerlink" title="2.皮肤包加载"></a>2.皮肤包加载</h5><ul><li>当皮肤管理类SkinManager加载一个皮肤包时，调用loadSkinPackage方法并传入皮肤包apk的本地路径</li><li>调用插件管理类PluginManager的loadApk方法，内部依次通过调用方法createDexClassLoader -&gt; createAssetManager -&gt; createResources分别实例化了DexClassLoader、AssetManager、Resources对象，作为获取皮肤包内资源的基础。</li><li>返回SkinManager内，再次调用PluginManager的removePackage方法，释放已加载的皮肤资源。</li><li>执行loadSkinPackageConfig方法，加载当前可用皮肤配置。</li><li>执行notifySkinChange方法，方法内部遍历通知所有注册监听皮肤加载事件的监听对象，以便这些对象能根据当前皮肤切换。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private PluginPackage preparePluginEnv(PackageInfo packageInfo, String dexPath) &#123;</span><br><span class="line">        PluginPackage pluginPackage = mPackagesHolder.get(packageInfo.packageName + packageInfo.versionCode);</span><br><span class="line">        if (pluginPackage != null) &#123;</span><br><span class="line">            return pluginPackage;</span><br><span class="line">        &#125;</span><br><span class="line">        DexClassLoader dexClassLoader = createDexClassLoader(dexPath);</span><br><span class="line">        AssetManager assetManager = createAssetManager(dexPath);</span><br><span class="line">        Resources resources = createResources(assetManager);</span><br><span class="line">        // create pluginPackage</span><br><span class="line">        pluginPackage = new PluginPackage(dexClassLoader, resources, packageInfo);</span><br><span class="line">        mPackagesHolder.put(pluginPackage.packageName + pluginPackage.versionCode, pluginPackage);</span><br><span class="line">        return pluginPackage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="3-主要类功能说明"><a href="#3-主要类功能说明" class="headerlink" title="3.主要类功能说明"></a>3.主要类功能说明</h5><ul><li>SkinPackage</li></ul><p>后端配置的皮肤信息，包括皮肤包下载地址、大小、包名、MD5、版本号，有效日期等信息，供下载使用。</p><ul><li>PluginPackage<br>皮肤包加载后的对象，维护DexClassLoader、AssetManager、Resources等信息，供获取包内资源使用。</li><li><p>SkinManager<br>该类为皮肤管理类，为单例类。维护着所有监听皮肤加载事件的监听对象，以及当前后端配置的活动皮肤（SkinPackage）和对应皮肤包（PluginPackage）信息。类提供加载皮肤包、注册/注销监听对象、清理过期皮肤的方法，以及获取皮肤包内资源的方法。</p></li><li><p>PluginManager<br>该类为皮肤包加载类，用来维护所有皮肤包（PluginPackage）信息，并对外提供唯一方法loadApk用来加载皮肤包。方法内分别实例化了DexClassLoader、AssetManager、Resources对象用来获取皮肤包内资源。</p></li><li>SkinDownloadServices<br>本类为皮肤下载服务类，当收到下载请求时，调用下载服务下载皮肤包。监听下载完成通知并调用SkinManager内方法加载皮肤包PluginPackage，并在加载完成后保存至数据库皮肤表中。</li><li>ISkinColor、ISkinDrawable<br>监听皮肤加载事件的接口对象，对象设定监听的资源ID，当皮肤加载时被回调，根据该ID从皮肤包内获取资源并返回给本对象。</li></ul><h3 id="新增一个皮肤包"><a href="#新增一个皮肤包" class="headerlink" title="新增一个皮肤包"></a>新增一个皮肤包</h3><p>下面介绍了怎样给免商店应用增加一个皮肤包用来换肤。</p><h5 id="修改免商店"><a href="#修改免商店" class="headerlink" title="修改免商店"></a>修改免商店</h5><p>为了便于开发，所有需要换肤的资源使用与免商店同一name，这样当加载皮肤包资源时仅需提供该同名资源名。<br>以左侧菜单栏换肤为例，菜单栏需要更换背景图片及部分字体颜色。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">iSkinDrawables.add(new ISkinDrawable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public int getDrawableResId() &#123;</span><br><span class="line">            return R.drawable.menu_account_bg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onDrawableChanged(Drawable drawable) &#123;</span><br><span class="line">            if (mAccountContainer != null) &#123;</span><br><span class="line">                mAccountContainer.setBackgroundDrawable(drawable);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public String getTag() &#123;</span><br><span class="line">            return TAG;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">for (ISkinDrawable iSkinDrawable : iSkinDrawables) &#123;</span><br><span class="line">         SkinManager.getInstance().registerSkinables(iSkinDrawable);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>1.实例化一个ISkinDrawable对象。<br>2.方法getDrawableResId返回主应用内该drawable的id，<br>3.方法onDrawableChanged接收回调时传回的drawable对象，当不为null时直接设置即可<br>4.方法getTag返回一个字符串，用来注销监听时移除该ISkinDrawable对象。<br>5.增加到iSkinDrawables监听队列，并注册队列中所有监听对象。<br>颜色：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">iSkinColors.add(new ISkinColor() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public int getColorResId() &#123;</span><br><span class="line">            return R.color.menu_title_color;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onColorChanged(int color) &#123;</span><br><span class="line">            if (slideMenuAdapter != null) &#123;</span><br><span class="line">                slideMenuAdapter.setMenuTitleColor(color);</span><br><span class="line">                slideMenuAdapter.notifyDataSetChanged();</span><br><span class="line">            &#125;</span><br><span class="line">            if (mMyWalletTitleView != null) &#123;</span><br><span class="line">                mMyWalletTitleView.setTextColor(color);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public String getTag() &#123;</span><br><span class="line">            return TAG;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">for (ISkinColor iSkinColor : iSkinColors) &#123;</span><br><span class="line">        SkinManager.getInstance().registerSkinables(iSkinColor);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>1.实例化一个ISkinColor对象。<br>2.其他步骤类似图片方式。</p><h5 id="新建皮肤工程"><a href="#新建皮肤工程" class="headerlink" title="新建皮肤工程"></a>新建皮肤工程</h5><p>由于皮肤包用来替换主应用的主题相关资源，所以只要新建一个工程，在资源目录res下增加图片、字符串、颜色等即可。<br>图片：</p><p>在drawable下新增一个同一资源名的图片或xml，支持不同分辨率目录下放置合适图片及其他drawable资源。<br>颜色：</p><p>在color.xml配置同一资源名的color资源，与普通颜色设置相同。<br>新增完成后，直接打包并签名，即可得到生成的皮肤包apk。</p><h4 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h4><p>参考运营提供的配置页面说明。将生成的皮肤包上传至服务端，并将该皮肤配置在有效期且状态为有效，其他皮肤配置禁用即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;content&lt;br&gt;{:toc}&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Android免商店动态加载皮肤&quot;&gt;&lt;a href=&quot;#Android免商店动态加载皮肤&quot; class=&quot;headerlink&quot; title=&quot;Android免商店动态加载皮肤&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="Android" scheme="http://zaijiangwangzhuan.com/categories/Android/"/>
    
    
      <category term="黑科技" scheme="http://zaijiangwangzhuan.com/tags/%E9%BB%91%E7%A7%91%E6%8A%80/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin学习</title>
    <link href="http://zaijiangwangzhuan.com/2017/07/17/2017-07-17-Kotlin%E5%AD%A6%E4%B9%A0/"/>
    <id>http://zaijiangwangzhuan.com/2017/07/17/2017-07-17-Kotlin学习/</id>
    <published>2017-07-17T08:00:00.000Z</published>
    <updated>2018-07-21T03:13:52.465Z</updated>
    
    <content type="html"><![CDATA[<ul><li>content<br>{:toc}</li></ul><p>kotlin 比较重要的两个网站<br><a href="https://kotlinlang.org/" target="_blank" rel="noopener">Kotlinlang.org</a><br><a href="https://try.kotlinlang.org/" target="_blank" rel="noopener">Kotlin Koans Online</a>: 一个可以通过在线编程学习kotlin网站</p><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><ul><li><p>声明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Invoice&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Person constructor(firstName: String)&#123;</span><br><span class="line">    init&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>主构造函数不能包含任何代码，可以放到init 关键字 初始化块中</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;content&lt;br&gt;{:toc}&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;kotlin 比较重要的两个网站&lt;br&gt;&lt;a href=&quot;https://kotlinlang.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Kotlinlang.org
      
    
    </summary>
    
      <category term="Android" scheme="http://zaijiangwangzhuan.com/categories/Android/"/>
    
    
      <category term="学习" scheme="http://zaijiangwangzhuan.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Android网站收录</title>
    <link href="http://zaijiangwangzhuan.com/2017/07/14/2017-07-14-Android%E7%BD%91%E7%AB%99%E6%94%B6%E5%BD%95/"/>
    <id>http://zaijiangwangzhuan.com/2017/07/14/2017-07-14-Android网站收录/</id>
    <published>2017-07-14T08:00:00.000Z</published>
    <updated>2018-07-21T03:13:52.465Z</updated>
    
    <content type="html"><![CDATA[<ul><li>content<br>{:toc}</li></ul><p><a href="http://repository.grepcode.com/java/ext/com/google/android/android-apps/" target="_blank" rel="noopener">Android 源码在线阅读</a></p><h2 id="网站收录"><a href="#网站收录" class="headerlink" title="网站收录"></a>网站收录</h2><p><a href="http://www.jcodecraeer.com/" target="_blank" rel="noopener">泡在网上的日子</a></p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p><a href="http://blog.csdn.net/devinteng/article/details/44809019" target="_blank" rel="noopener">HttpUrlConnection支持Header,Body传值，支持Multipart上传文件</a><br><a href="http://blog.csdn.net/sheilazxx/article/details/53259543" target="_blank" rel="noopener">解决android 6.0 webview加载https出现空白页问题</a></p><p><a href="http://kresnik.wang/works/tech/2015/06/07/%E5%9C%A8github-pages%E7%BD%91%E7%AB%99%E4%B8%8B%E7%94%A8jekyll%E5%88%B6%E4%BD%9C%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B.html" target="_blank" rel="noopener">在github pages网站下用jekyll制作博客教程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;content&lt;br&gt;{:toc}&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;http://repository.grepcode.com/java/ext/com/google/android/android-apps/&quot; target=&quot;_blank&quot; 
      
    
    </summary>
    
      <category term="Android" scheme="http://zaijiangwangzhuan.com/categories/Android/"/>
    
    
      <category term="学习" scheme="http://zaijiangwangzhuan.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Android知识集合</title>
    <link href="http://zaijiangwangzhuan.com/2017/06/20/2017-06-20-Android%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/"/>
    <id>http://zaijiangwangzhuan.com/2017/06/20/2017-06-20-Android知识集合/</id>
    <published>2017-06-20T08:00:00.000Z</published>
    <updated>2018-07-21T03:13:52.464Z</updated>
    
    <content type="html"><![CDATA[<ul><li>content<br>{:toc}</li></ul><h3 id="Activity的几种LaunchMode及使用场景"><a href="#Activity的几种LaunchMode及使用场景" class="headerlink" title="Activity的几种LaunchMode及使用场景"></a>Activity的几种LaunchMode及使用场景</h3><h4 id="standard-模式"><a href="#standard-模式" class="headerlink" title="standard 模式"></a>standard 模式</h4><p> 这是默认模式，每次激活Activity时都会创建Activity实例，并放入任务栈中。使用场景：大多数Activity。</p><h4 id="singleTop-模式"><a href="#singleTop-模式" class="headerlink" title="singleTop 模式"></a>singleTop 模式</h4><p>如果在任务栈顶正好存在改Activity ，就重用该Activity( 会调用实例的 onNewIntent() ), 使用场景 如通知栏 点击重复进入Activity</p><h4 id="singleTask-模式"><a href="#singleTask-模式" class="headerlink" title="singleTask 模式"></a>singleTask 模式</h4><p>如果任务栈堆 有该Activity 就重用该实例，重用时 会让该实例回到栈顶 ，之前在它上面的实例会被移除  使用场景如 主界面  需要清空上面所有activity的情况</p><h4 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h4><p>单一实例模式， 整个手机操作系统只有一个实例 使用场景如: 呼叫来电</p><h3 id="如何理解Activity，View，Window三者之间的关系？"><a href="#如何理解Activity，View，Window三者之间的关系？" class="headerlink" title="如何理解Activity，View，Window三者之间的关系？"></a>如何理解Activity，View，Window三者之间的关系？</h3><blockquote><p>Activity 是android 应用组件，提供一个屏幕 共用户交互 。每个activity会给于一个窗口 在上面可以绘制view</p></blockquote><p>1: Activity构造的时候会初始化一个Window，准确的说是PhoneWindow。</p><p>2: 这个PhoneWindow有一个“ViewRoot”，这个“ViewRoot”是一个View或者说ViewGroup，是最初始的根视图。</p><p>3：“ViewRoot”通过addView方法来一个个的添加View。比如TextView，Button等</p><p>4：这些View的事件监听，是由WindowManagerService来接受消息，并且回调Activity函数。比如onClickListener，onKeyDown等。</p><p>Activity 层级关系：每个Activity包含一个PhoneWindow对象，PhoneWindow设置DecorView为应用窗口的根视图。在里面就是熟悉的TitleView和ContentView,没错，平时使用的setContentView()就是设置的ContentView</p><h3 id="启动service的两种方法和区别"><a href="#启动service的两种方法和区别" class="headerlink" title="启动service的两种方法和区别"></a>启动service的两种方法和区别</h3><p>startService 和 bindService， startService 启动后即与调用者没关系了 关闭需调用stopService, bindService与调用者绑定在一起可以进行通信 关闭了调用者服务也退出了</p><h3 id="Service-是否在-main-thread-中执行-service-里面是否能执行耗时的操作"><a href="#Service-是否在-main-thread-中执行-service-里面是否能执行耗时的操作" class="headerlink" title="Service 是否在 main thread 中执行, service 里面是否能执行耗时的操作"></a>Service 是否在 main thread 中执行, service 里面是否能执行耗时的操作</h3><h3 id="RecyleView-和-ListView"><a href="#RecyleView-和-ListView" class="headerlink" title="RecyleView 和 ListView"></a>RecyleView 和 ListView</h3><h3 id="Android-TouchEvent事件分发机制"><a href="#Android-TouchEvent事件分发机制" class="headerlink" title="Android TouchEvent事件分发机制"></a>Android TouchEvent事件分发机制</h3><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td>dispatchTouchEvent()</td><td>用来分派事件。其中调用了onInterceptTouchEvent()和onTouchEvent()，一般不重写该方法</td></tr><tr><td>onInterceptTouchEvent()</td><td>用来拦截事件。ViewGroup类中的源码实现就是{return false;}表示不拦截该事件，事件将向下传递（传递给其子View）；若手动重写该方法，使其返回true则表示拦截，事件将终止向下传递，事件由当前ViewGroup类来处理，就是调用该类的onTouchEvent()方法</td></tr><tr><td>onTouchEvent（）</td><td>用来处理事件。返回true则表示该View能处理该事件，事件将终止向上传递（传递给其父View）；返回false表示不能处理，则把事件传递给其父View的onTouchEvent()方法来处理</td></tr></tbody></table><p><a href="http://blog.csdn.net/morgan_xww/article/details/9372285" target="_blank" rel="noopener">TouchEvent事件分发机制</a></p><h3 id="Android-View的绘制流程"><a href="#Android-View的绘制流程" class="headerlink" title="Android View的绘制流程"></a>Android View的绘制流程</h3><p>可以经过三个过程 measure、layout、draw 过程<br><a href="http://www.codekk.com/blogs/detail/54cfab086c4761e5001b253f" target="_blank" rel="noopener">参考链接</a></p><h3 id="Android-跨进程通讯的几种方式"><a href="#Android-跨进程通讯的几种方式" class="headerlink" title="Android 跨进程通讯的几种方式"></a>Android 跨进程通讯的几种方式</h3><p>1.通过Intent访问其他应用程序Activity</p><ol start="2"><li>Content Provider  访问系统相册</li><li>广播</li><li>AIDL 服务</li></ol><h3 id="Handler的原理"><a href="#Handler的原理" class="headerlink" title="Handler的原理"></a>Handler的原理</h3><ul><li>使用场景 handler 一般用于延时操作或接收子线程发送的数据， 用此数据配合主线程更新UI。  </li><li>原理: Looper负责创建MessageQueue 然后无限循环的从MessageQueue中读取 handler发过来的消息</li></ul><p><a href="http://blog.csdn.net/lmj623565791/article/details/38377229" target="_blank" rel="noopener">参考链接</a></p><h3 id="Binder机制原理"><a href="#Binder机制原理" class="headerlink" title="Binder机制原理"></a>Binder机制原理</h3><p><a href="http://blog.csdn.net/boyupeng/article/details/47011383" target="_blank" rel="noopener">参考链接</a></p><h3 id="AsyncTask-相关"><a href="#AsyncTask-相关" class="headerlink" title="AsyncTask 相关"></a>AsyncTask 相关</h3><h5 id="AsynTask内部实行-使用场景"><a href="#AsynTask内部实行-使用场景" class="headerlink" title="AsynTask内部实行 使用场景"></a>AsynTask内部实行 使用场景</h5><p>内部是通过Handler 机制来完成，Android提供执行框架来提供线程池执行相关任务，因为线程池的大小问题 只能执行耗时短的任务如http请求对于大规模下载不适用AysncTask会造成线程池堵塞 发现AysncTask执行不了</p><h5 id="1-AsynTask为什么要设计为只能够一次任务？"><a href="#1-AsynTask为什么要设计为只能够一次任务？" class="headerlink" title="1.AsynTask为什么要设计为只能够一次任务？"></a>1.AsynTask为什么要设计为只能够一次任务？</h5><p> 最核心的还是线程安全问题，多个子线程同时运行，会产生状态不一致的问题。所以要务必保证只能够执行一次</p><h5 id="2-AsynTask造成的内存泄露的问题怎么解决"><a href="#2-AsynTask造成的内存泄露的问题怎么解决" class="headerlink" title="2.AsynTask造成的内存泄露的问题怎么解决"></a>2.AsynTask造成的内存泄露的问题怎么解决</h5><p> 比如非静态内部类AsynTask会隐式地持有外部类的引用，如果其生命周期大于外部activity的生命周期，就会出现内存泄漏注意要复写AsynTask的onCancel方法，把里面的socket，file等，该关掉的要及时关掉在 Activity 的onDestory()方法中调用Asyntask.cancal方法Asyntask内部使用弱引用的方式来持有Activity</p><h5 id="3-若Activity已经销毁，此时AsynTask执行完并且返回结果，会报异常吗"><a href="#3-若Activity已经销毁，此时AsynTask执行完并且返回结果，会报异常吗" class="headerlink" title="3. 若Activity已经销毁，此时AsynTask执行完并且返回结果，会报异常吗?"></a>3. 若Activity已经销毁，此时AsynTask执行完并且返回结果，会报异常吗?</h5><p> 当一个App旋转时，整个Activity会被销毁和重建。当Activity重启时，AsyncTask中对该Activity的引用是无效的，因此onPostExecute()就不会起作用，若AsynTask正在执行，折会报 view not attached to window manager 异常同样也是生命周期的问题，在 Activity 的onDestory()方法中调用Asyntask.cancal方法，让二者的生命周期同步</p><h5 id="4-Activity销毁但Task如果没有销毁掉，当Activity重启时这个AsyncTask该如何解决？"><a href="#4-Activity销毁但Task如果没有销毁掉，当Activity重启时这个AsyncTask该如何解决？" class="headerlink" title="4. Activity销毁但Task如果没有销毁掉，当Activity重启时这个AsyncTask该如何解决？"></a>4. Activity销毁但Task如果没有销毁掉，当Activity重启时这个AsyncTask该如何解决？</h5><p>还是屏幕旋转这个例子，在重建Activity的时候，会回掉Activity.onRetainNonConfigurationInstance()重新传递一个新的对象给AsyncTask，完成引用的更新</p><h3 id="ANR"><a href="#ANR" class="headerlink" title="ANR"></a>ANR</h3><p>应用程序在一段时间不够灵敏，系统就会显示一个对话框</p><h5 id="产生的原因"><a href="#产生的原因" class="headerlink" title="产生的原因:"></a>产生的原因:</h5><ol><li>来自AMS的回调消息 当AMS对应用组件的生命周期进行回调的时间超过自定义的响应时间就会包ANR，回调函数及超过时间如下:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Activity: onCreate(), onResume(), onDestroy(), </span><br><span class="line">onKeyDown(), onClick()等，超时时间5s</span><br><span class="line"></span><br><span class="line">Application: onCreate(), onTerminate()等，超时时间5s</span><br><span class="line"></span><br><span class="line">Service: onCreate(), onStart(), onDestroy()等，超时时间20s</span><br><span class="line"></span><br><span class="line">BroadcastReceiver：onReceiver()，前台APP广播超时时间是10s，后台App是60s</span><br></pre></td></tr></table></figure><ol start="2"><li>App 其他操作运行在UI线程的</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AsyncTask: onPreExecute(), onProgressUpdate(), onPostExecute(), onCancel()等，超时5s</span><br><span class="line"></span><br><span class="line">Mainthread handler: handleMessage(), post*(runnable r)等，超时5s</span><br></pre></td></tr></table></figure><h5 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h5><ol><li>耗时操作放入子线程中</li><li>使用handler 来处理UI 线程和其他线程的交互</li></ol><p><a href="http://www.jianshu.com/p/124f3b75e164" target="_blank" rel="noopener">参考链接</a></p><h3 id="Android内存泄漏"><a href="#Android内存泄漏" class="headerlink" title="Android内存泄漏"></a>Android内存泄漏</h3><p>当一个对象已经不需要使用了，本该回收的时候，另一个正在使用的对象持有它的引用导致它不能被回收 这不能回收的对象就在推内存中，就产生了内存泄漏  当内存超出系统分配的内存限额 引用就会Crash</p><ul><li>常见内存泄漏汇总</li></ul><ol><li>单例造成的内存泄漏</li><li>非静态内部类 创建静态实例造成的内存泄漏</li><li>Handler造成的内存泄漏</li><li>线程造成的泄漏</li><li>资源未关闭造成的内存泄漏</li></ol><p><a href="https://juejin.im/entry/56d64b9e816dfa005943a55c" target="_blank" rel="noopener">参考链接</a></p><h3 id="布局优化"><a href="#布局优化" class="headerlink" title="布局优化"></a>布局优化</h3><p>1.合理选择控件容器， 尽量减少层次 相同层次使用LinearLayout</p><ol start="2"><li>去掉window的默认背景</li><li>去掉其他不别要的背景<br>4.ViewStub 高效占位符， 对于比较复杂的需要显示隐藏的布局 可以通过viewStub 控制</li><li>Merge</li></ol><h3 id="图片优化"><a href="#图片优化" class="headerlink" title="图片优化"></a>图片优化</h3><p>一些优化方案  非重点<br><a href="http://www.jianshu.com/p/5bb8c01e2bc7" target="_blank" rel="noopener">参考链接</a></p><h3 id="图片缓存"><a href="#图片缓存" class="headerlink" title="图片缓存"></a>图片缓存</h3><p>内存缓存 LruCache + 磁盘缓存 DiskLruCache + 网络请求 组成三级缓存</p><h3 id="热修复原理"><a href="#热修复原理" class="headerlink" title="热修复原理"></a>热修复原理</h3><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>MVC MVP MVVM</p><h3 id="设计架构"><a href="#设计架构" class="headerlink" title="设计架构"></a>设计架构</h3><p><a href="https://juejin.im/entry/56ebb4ad5bbb50004c440972" target="_blank" rel="noopener">参考链接</a></p><h3 id="RXJAVA"><a href="#RXJAVA" class="headerlink" title="RXJAVA"></a>RXJAVA</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;content&lt;br&gt;{:toc}&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Activity的几种LaunchMode及使用场景&quot;&gt;&lt;a href=&quot;#Activity的几种LaunchMode及使用场景&quot; class=&quot;headerlink&quot; title=&quot;Ac
      
    
    </summary>
    
      <category term="Android" scheme="http://zaijiangwangzhuan.com/categories/Android/"/>
    
    
      <category term="面试" scheme="http://zaijiangwangzhuan.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Java知识集合</title>
    <link href="http://zaijiangwangzhuan.com/2017/06/19/2017-06-19-Java%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/"/>
    <id>http://zaijiangwangzhuan.com/2017/06/19/2017-06-19-Java知识集合/</id>
    <published>2017-06-19T08:00:00.000Z</published>
    <updated>2018-07-21T03:13:52.463Z</updated>
    
    <content type="html"><![CDATA[<ul><li>content<br>{:toc}</li></ul><h3 id="接口和抽象类的意义"><a href="#接口和抽象类的意义" class="headerlink" title="接口和抽象类的意义"></a>接口和抽象类的意义</h3><p>抽象类一般用于抽象出共有特性比如 亚洲人和人<br>接口一般用于某种特殊 操作的特性 比如女人生娃  </p><h3 id="JAVA-GC（回收）原理"><a href="#JAVA-GC（回收）原理" class="headerlink" title="JAVA GC（回收）原理"></a>JAVA GC（回收）原理</h3><p>JAVA 通过GC 确认对象是否被其他引用 确定是否收集该对象</p><h5 id="触发的条件（时间）"><a href="#触发的条件（时间）" class="headerlink" title="触发的条件（时间）"></a>触发的条件（时间）</h5><p>1.GC在优先级最低的线程中运行 所以在应用程序空闲的时候被调用<br>2.当JAVA堆内存不足的时候</p><h5 id="对谁回收"><a href="#对谁回收" class="headerlink" title="对谁回收"></a>对谁回收</h5><p>把内存分为几块，年轻化 老年块， 对年轻块使用效率较高的算法 如果对象经过几轮都没被回收就进入老年块 采用不同的算法回收</p><h5 id="减少GC开销的措施"><a href="#减少GC开销的措施" class="headerlink" title="减少GC开销的措施"></a>减少GC开销的措施</h5><ol><li>减少临时对象的使用</li><li>对象不用的时候设置为null</li><li>对于操作string 尽量用stringbuffer</li><li>少用静态对象变量</li><li>能用基本内形用基本内形</li></ol><h3 id="JAVA-反射原理"><a href="#JAVA-反射原理" class="headerlink" title="JAVA 反射原理"></a>JAVA 反射原理</h3><p><a href="http://www.jianshu.com/p/3968ffabdf9d" target="_blank" rel="noopener">参考链接</a></p><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><h3 id="强引用-软引用-弱引用-虚引用"><a href="#强引用-软引用-弱引用-虚引用" class="headerlink" title="强引用 软引用 弱引用 虚引用"></a>强引用 软引用 弱引用 虚引用</h3><ul><li>强引用: 不会被回收 即使当前内存不足</li><li>软引用SoftReference: 内存足够继续使用，当内存不足时会回收 比如图片加载框架</li><li>弱引用WeakReference: JVM(Java 虚拟机)进行垃圾回收时 无论内存是否充足就会被回收<br>比如Handler持有Activity</li><li>虚拟用: </li></ul><p>对象经常使用就使用软引用，如果不被使用的可能性更大 就是用弱引用</p><h3 id="String-StringBuffer-与StringBuilder的区别"><a href="#String-StringBuffer-与StringBuilder的区别" class="headerlink" title="String StringBuffer 与StringBuilder的区别"></a>String StringBuffer 与StringBuilder的区别</h3><p>String 是不可变的对象 ,StringBuffer和 StringBuilder底层是char[]数组实现的，StringBuffer是线程安全 StringBuilder是线程不安全</p><h3 id="用过哪些集合类有哪些"><a href="#用过哪些集合类有哪些" class="headerlink" title="用过哪些集合类有哪些"></a>用过哪些集合类有哪些</h3><p>数组 和 链表</p><h3 id="ArrayList-LinkedList-Vector的区别"><a href="#ArrayList-LinkedList-Vector的区别" class="headerlink" title="ArrayList,LinkedList Vector的区别"></a>ArrayList,LinkedList Vector的区别</h3><p>ArrayList 基于动态数组的数据结构  get set有优势  线程不同步不过性能好<br>LinkedList 基于链表的数据结构  新增和删除有优势<br>Vector 基于数据的数据结构  线程同步</p><h3 id="Thread中sleep-和-wait-区别"><a href="#Thread中sleep-和-wait-区别" class="headerlink" title="Thread中sleep 和 wait 区别"></a>Thread中sleep 和 wait 区别</h3><p>sleep 不会释放对象所 wait会释放对象所<br>sleep 不会出让系统资源 wait可以占有<br>sleep 需要指定一个睡眠时间 </p><h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><table><thead><tr><th>排序算法</th><th>思想</th></tr></thead><tbody><tr><td>冒泡排序</td><td>两个数比较大小，较大的数下沉，较小的数冒起来</td></tr><tr><td>选择排序</td><td>在长度为N的无序数组中，第i++次遍历n-i个数，找到最小的数值与i元素交换</td></tr><tr><td>插入排序</td><td>假定前n-1个数已经排好序，现在将第n个数插到前面的有序数列中</td></tr><tr><td>希尔排序</td><td>某一增量分为若干子序列 对子序列插排 然后减小增量再插排</td></tr><tr><td>快速排序</td><td>从数列中取一个数 小的放左边大的放右边，再对左右两边重复这个操作</td></tr><tr><td>归并排序</td><td></td></tr><tr><td>堆排序</td><td></td></tr></tbody></table><p><a href="http://www.jianshu.com/p/ae97c3ceea8d" target="_blank" rel="noopener">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;content&lt;br&gt;{:toc}&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;接口和抽象类的意义&quot;&gt;&lt;a href=&quot;#接口和抽象类的意义&quot; class=&quot;headerlink&quot; title=&quot;接口和抽象类的意义&quot;&gt;&lt;/a&gt;接口和抽象类的意义&lt;/h3&gt;&lt;p&gt;抽象类一
      
    
    </summary>
    
      <category term="Java" scheme="http://zaijiangwangzhuan.com/categories/Java/"/>
    
    
      <category term="面试" scheme="http://zaijiangwangzhuan.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Android设计模式</title>
    <link href="http://zaijiangwangzhuan.com/2017/06/18/2017-06-18-Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://zaijiangwangzhuan.com/2017/06/18/2017-06-18-Android设计模式/</id>
    <published>2017-06-18T08:46:00.000Z</published>
    <updated>2018-07-21T03:13:52.463Z</updated>
    
    <content type="html"><![CDATA[<ul><li>content<br>{:toc}</li></ul><p>按照 设计模式定义–&gt; 通常在什么情况使用 –&gt; 示例</p><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><blockquote><p>（1）基本定义：设计模式（Design pattern）是一套被反复使用的代码设计经验的总结。使用设计模式的目的是为了可重用代码、让代码更容易被他人理解。设计模式是是软件工程的基石脉络，如大厦的结构一样。</p></blockquote><blockquote><p>（2）Design pattern的四大要素：模式名称（Name），问题（Question），解决方案（Solution），效果（Efftive）。</p></blockquote><blockquote><p>（3）OO（面向对象）的六大原则：单一职责原则，开闭原则，里氏替换原则，依赖倒置原则，接口隔离原则，迪米特原则。</p></blockquote><blockquote><p>单一职责原则：一个类中应该是一组相关性很高的函数，数据的封装。两个完全不一样的功能就不应该放在一个类中。</p></blockquote><blockquote><p>开闭原则：对修改封闭，对扩展放开。</p></blockquote><blockquote><p>里氏替换原则：抽象和继承；所有引用基类的地方必须能透明的使用其子类的对象。</p></blockquote><blockquote><p>依赖倒置原则：抽象不应该依赖细节，细节应该依赖抽象。</p></blockquote><blockquote><p>接口隔离原则：将大接口改成多个小接口。</p></blockquote><blockquote><p>迪米特原则：也称为最少知识原则，一个对象应该对另一个对象有最少的了解。</p></blockquote><h3 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h3><p>设计模式分为三种类型：</p><blockquote><p>（1）创建型模式5种：单例模式，抽象工厂模式，工厂模式，原型模式，建造者模式。<br>（口诀：单原建造者，东西二厂）</p></blockquote><blockquote><p>（2）结构型模式7种：适配器模式，桥接模式，装饰模式，组合模式，外观模式，享元模式，代理模式。<br>（口诀：一器一桥一元一代理；装饰组合外观）</p></blockquote><blockquote><p>（3）行为型模式11种：观察者模式，中介者模式，访问者模式，解释器模式，迭代器模式，备忘录模式，责任链模式，状态模式，策略模式，命令模式，模板模式。<br>（口诀：三者两器、一录一链一模板，状态策略命令）</p></blockquote><h4 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1. 单例模式"></a>1. 单例模式</h4><blockquote><p>确保一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。</p></blockquote><h4 id="App-只需要一个类-实例，或者类的初始化操作比较耗费资源，-不如-网络加载和-图片加载"><a href="#App-只需要一个类-实例，或者类的初始化操作比较耗费资源，-不如-网络加载和-图片加载" class="headerlink" title="App 只需要一个类 实例，或者类的初始化操作比较耗费资源， 不如 网络加载和 图片加载"></a>App 只需要一个类 实例，或者类的初始化操作比较耗费资源， 不如 网络加载和 图片加载</h4><ul><li>Android中的系统级服务都是通过容器的单例模式实现方式，以单例形式存在，减少了资源消耗 如 LayoutInflater Service， ActivityManager InputMethodManager AccessibilityManager 中 getInstance 都是单例</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static volatile Singleton instance = null;</span><br><span class="line"></span><br><span class="line">    private Singleton()&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                if (instance == null) &#123;</span><br><span class="line">                    instance = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-Builder-建造者-模式"><a href="#2-Builder-建造者-模式" class="headerlink" title="2.Builder(建造者)模式"></a>2.Builder(建造者)模式</h3><blockquote><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</p></blockquote><h4 id="一个类的构造需要很多参数，而且这些参数都不是必须的，就比较适合Builder"><a href="#一个类的构造需要很多参数，而且这些参数都不是必须的，就比较适合Builder" class="headerlink" title="一个类的构造需要很多参数，而且这些参数都不是必须的，就比较适合Builder"></a>一个类的构造需要很多参数，而且这些参数都不是必须的，就比较适合Builder</h4><ul><li><p>Android中最常用的就是Dialog的构建，Notification的构建也是标准的建造者模式。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private double height;</span><br><span class="line">    private double weight;</span><br><span class="line"></span><br><span class="line">    privatePerson(Builder builder) &#123;</span><br><span class="line">        this.name=builder.name;</span><br><span class="line">        this.age=builder.age;</span><br><span class="line">        this.height=builder.height;</span><br><span class="line">        this.weight=builder.weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Get @Set</span><br><span class="line">    static class Builder&#123;</span><br><span class="line">        private String name;</span><br><span class="line">        private int age;</span><br><span class="line">        private double height;</span><br><span class="line">        private double weight;</span><br><span class="line">        public Builder name(String name)&#123;</span><br><span class="line">            this.name=name;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">        public Builder age(int age)&#123;</span><br><span class="line">            this.age=age;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">        public Builder height(double height)&#123;</span><br><span class="line">            this.height=height;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Builder weight(double weight)&#123;</span><br><span class="line">            this.weight=weight;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Person build()&#123;</span><br><span class="line">            return new Person(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样创建Person 类就可以这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> Person.Builder builder=new Person.Builder();</span><br><span class="line">Person person=builder</span><br><span class="line">.name(&quot;张三&quot;)</span><br><span class="line">.age(18)</span><br><span class="line">.height(178.5)</span><br><span class="line">.weight(67.4)</span><br><span class="line">.build();</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-工厂方法模式"><a href="#3-工厂方法模式" class="headerlink" title="3. 工厂方法模式"></a>3. 工厂方法模式</h3><blockquote><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类。</p></blockquote><p>示例：BitmapFactory位图工厂，专门用来将指定的图片转换为指定的位图Bitmap。</p><h3 id="4-抽象工厂模式"><a href="#4-抽象工厂模式" class="headerlink" title="4. 抽象工厂模式"></a>4. 抽象工厂模式</h3><blockquote><p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p></blockquote><p>Android底层对MediaPlayer的创建。<br>MediaPlayerFactory是Android底层为了创建不同的MediaPlayer所定义的一个类。</p><h3 id="5-原型模式"><a href="#5-原型模式" class="headerlink" title="5. 原型模式"></a>5. 原型模式</h3><blockquote><p>用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象</p></blockquote><p>比如我们需要一张Bitmap的几种不同格式：ARGB_8888、RGB_565、ARGB_4444、ALAPHA_8等。那我们就可以先创建一个ARGB_8888的Bitmap作为原型，在它的基础上，通过调用Bitmap.copy(Config)来创建出其它几种格式的Bitmap。另外一个例子就是Java中所有对象都有的一个名字叫clone的方法，已经原型模式的代名词了。在系统中要创建大量的对象，这些对象之间具有几乎完全相同的功能，只是在细节上有一点儿差别。</p><h3 id="6-适配器模式"><a href="#6-适配器模式" class="headerlink" title="6. 适配器模式"></a>6. 适配器模式</h3><blockquote><p>将一个类的接口转换成客户希望的另外一个接口</p></blockquote><p>不同的数据提供者使用一个适配器来向一个相同的客户提供服务。ListView或GridView的Adapter。</p><h3 id="7-组合模式"><a href="#7-组合模式" class="headerlink" title="7. 组合模式"></a>7. 组合模式</h3><blockquote><p>将对象组合成树形结构以表示“部分-整体”的层次结构。</p></blockquote><p>示例：View和ViewGroup的组合</p><h3 id="8-桥接模式"><a href="#8-桥接模式" class="headerlink" title="8.桥接模式"></a>8.桥接模式</h3><blockquote><p>将抽象部分与它的实现部分分离，使它们都可以独立地变化</p></blockquote><p>示例：Window和WindowManager之间的关系。<br>在FrameWork中Window和PhoneWindow构成窗口的抽象部分，其中Window类为该抽象部分的抽象接口，PhoneWindow为抽象部分具体的实现及扩展。而WindowManager则为实现部分的基类，WindowManagerImpl则为实现部分具体的逻辑实现。</p><h3 id="9-装饰模式"><a href="#9-装饰模式" class="headerlink" title="9. 装饰模式"></a>9. 装饰模式</h3><blockquote><p>动态地给一个对象添加一些额外的职责。就扩展功能而言， 它比生成子类方式更为灵活。</p></blockquote><p>示例：Activity继承自ContextThemeWrapper，ContextThemeWrapper继承自ContextWrapper，ContextWrapper才是继承自Context。ContextWrapper就是我们找的装饰者。</p><h3 id="10-外观模式"><a href="#10-外观模式" class="headerlink" title="10.外观模式"></a>10.外观模式</h3><blockquote><p>为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，统一编程接口。</p></blockquote><p>示例：ContextImpl</p><h3 id="11-享元模式"><a href="#11-享元模式" class="headerlink" title="11.享元模式"></a>11.享元模式</h3><blockquote><p>运用共享技术有效地支持大量细粒度的对象</p></blockquote><p>示例：Message.obtainMessage通过重用Message对象来避免大量的Message对象被频繁的创建和销毁。</p><h3 id="12-代理模式"><a href="#12-代理模式" class="headerlink" title="12. 代理模式"></a>12. 代理模式</h3><blockquote><p>为其他对象提供一个代理以控制对这个对象的访问。</p></blockquote><p>示例：所有的AIDL都一个代理模式的例子。假设一个Activity A去绑定一个Service S，那么A调用S中的每一个方法其实都是通过系统的Binder机制的中转，然后调用S中的对应方法来做到的。Binder机制就起到了代理的作用。</p><h3 id="13-观察者模式"><a href="#13-观察者模式" class="headerlink" title="13. 观察者模式"></a>13. 观察者模式</h3><blockquote><p>一个对象发生改变时，所有信赖于它的对象自动做相应改变。</p></blockquote><p>示例：我们可以通过BaseAdapter.registerDataSetObserver和BaseAdapter.unregisterDataSetObserver两方法来向BaseAdater注册、注销一个DataSetObserver。这个过程中，DataSetObserver就是一个观察者，它一旦发现BaseAdapter内部数据有变量，就会通过回调方法DataSetObserver.onChanged和DataSetObserver.onInvalidated来通知DataSetObserver的实现类。事件通知也是观察者模式。</p><h3 id="14-中介者模式"><a href="#14-中介者模式" class="headerlink" title="14. 中介者模式"></a>14. 中介者模式</h3><blockquote><p>用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。<br>示例：Binder机制。</p></blockquote><h3 id="15-访问者模式"><a href="#15-访问者模式" class="headerlink" title="15.访问者模式:"></a>15.访问者模式:</h3><blockquote><p>表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p></blockquote><p>示例：编译时注解中的ElementVisitor中定义多个Visit接口，每个接口处理一种数据类型，这就是典型的访问者模式，访问者模式正好解决了数据结构和数据操作分离的问题，避免某些操作污染了数据对象类。</p><h3 id="16-解释器模式："><a href="#16-解释器模式：" class="headerlink" title="16. 解释器模式："></a>16. 解释器模式：</h3><blockquote><p>给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。<br>示例：PackageParser这个类对AndroidManifest.xml这个配置文件的解析过程，</p></blockquote><h3 id="17迭代器模式"><a href="#17迭代器模式" class="headerlink" title="17迭代器模式"></a>17迭代器模式</h3><blockquote><p>提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。</p></blockquote><p>示例：在Android中除了各种数据结构体，如List，Map，等包含的迭代器以外，Android源码中也提供了迭代器遍历模式，比如数据库查询使用Cursor，当我们使用SQLiteDataBase的query方法查询数据库时，会返回一个Cursor游标对象，该游标对象实际上就是一个具体的迭代器。</p><h3 id="18-备忘录模式"><a href="#18-备忘录模式" class="headerlink" title="18 备忘录模式"></a>18 备忘录模式</h3><blockquote><p>不需要了解对象的内部结构的情况下备份对象的状态，方便以后恢复。</p></blockquote><p>示例：Activity的onSaveInstanceState和onRestoreInstanceState就是通过Bundle这种序列化的数据结构来存储Activity的状态，至于其中存储的数据结构，这两个方法不用关心。</p><h3 id="19-责任链模式"><a href="#19-责任链模式" class="headerlink" title="19.责任链模式"></a>19.责任链模式</h3><blockquote><p>有多个的对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定。</p></blockquote><p>示例:  责任链模式在Android源码中比较类似的实现莫过于对事件的分发处理，每当用户接触屏幕时候，Android都会将对应的事件包装成一个事件对象从ViewTree的顶部至上而下的分发传递。ViewGroup事件投递的递归调用就类似一条责任链，一旦寻找到责任者，那么就由责任者持有并消费该次事件，具体的体现在View的onTouchEvent方法中的返回值，如果OnTouchEvent返回false，那么意味着当前View不会是该次事件的责任人，将不会对该事件持有。</p><h3 id="20-状态模式："><a href="#20-状态模式：" class="headerlink" title="20. 状态模式："></a>20. 状态模式：</h3><blockquote><p>状态发生改变时，行为改变。</p></blockquote><p>示例：View.onVisibilityChanged方法，就是提供了一个状态模式的实现，允许在View的visibility发生改变时，引发执行onVisibilityChanged方法中的动作。</p><h3 id="21-策略模式"><a href="#21-策略模式" class="headerlink" title="21.策略模式"></a>21.策略模式</h3><blockquote><p>定义了一系列封装了算法、行为的对象，他们可以相互替换。</p></blockquote><p>示例：Java.util.List就是定义了一个增（add）、删（remove）、改（set）、查（indexOf）策略，至于实现这个策略的ArrayList、LinkedList等类，只是在具体实现时采用了不同的算法。但因为它们策略一样，不考虑速度的情况下，使用时完全可以互相替换使用。</p><h3 id="22-命令模式"><a href="#22-命令模式" class="headerlink" title="22.命令模式"></a>22.命令模式</h3><blockquote><p>把请求封装成一个对象发送出去，方便定制、排队、取消。<br>示例：Handler.post后Handler.handleMessage。</p></blockquote><h3 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h3><blockquote><p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。是基于继承的代码复用的基本模式。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;content&lt;br&gt;{:toc}&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;按照 设计模式定义–&amp;gt; 通常在什么情况使用 –&amp;gt; 示例&lt;/p&gt;
&lt;h3 id=&quot;设计模式&quot;&gt;&lt;a href=&quot;#设计模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式&quot;
      
    
    </summary>
    
      <category term="Android" scheme="http://zaijiangwangzhuan.com/categories/Android/"/>
    
    
      <category term="面试" scheme="http://zaijiangwangzhuan.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>利用AccessibilityService实现免Root自动安装</title>
    <link href="http://zaijiangwangzhuan.com/2015/09/09/2015-09-09-%E5%88%A9%E7%94%A8AccessibilityService%E5%AE%9E%E7%8E%B0%E5%85%8DRoot%E8%87%AA%E5%8A%A8%E5%AE%89%E8%A3%85/"/>
    <id>http://zaijiangwangzhuan.com/2015/09/09/2015-09-09-利用AccessibilityService实现免Root自动安装/</id>
    <published>2015-09-09T08:46:00.000Z</published>
    <updated>2018-07-21T03:13:52.462Z</updated>
    
    <content type="html"><![CDATA[<h2 id="利用AccessibilityService实现免Root自动安装"><a href="#利用AccessibilityService实现免Root自动安装" class="headerlink" title="利用AccessibilityService实现免Root自动安装"></a>利用AccessibilityService实现免Root自动安装</h2><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>AccessibilityService运行在后台</p><p>它能够收到由系统发出的一些事件 比如焦点改变,输入内容变化,按钮被点击了等等。</p><p>并且该种服务能够通过查找text得到text对应的控件,这就可以实现我们的需求 通过对查找的控件实现点击操作</p><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题:"></a>遇到的问题:</h3><ol><li>有的手机确定点不到<br>解决方案, 反编译 360代码getRootInActiveWindow() 来 代替 event.getSource</li><li>针对不同的系统,<br>使用TextView 和 Button 来查找是否是符合的</li><li>对于定制的系统,安装 package 不一定相同 使用不同的package</li></ol><p>废话不多说上代码</p><ol><li><p>AndroidManifest.xml 注册Service</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;service</span><br><span class="line">android:name=&quot;.settings.AutoInstallAccessibilityService&quot;</span><br><span class="line">android:label=&quot;@string/setting_auto_install_acc_service_name&quot;</span><br><span class="line">android:permission=&quot;android.permission.BIND_ACCESSIBILITY_SERVICE&quot;&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=&quot;android.accessibilityservice.AccessibilityService&quot; /&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">    &lt;meta-data</span><br><span class="line">android:name=&quot;android.accessibilityservice&quot;</span><br><span class="line">android:resource=&quot;@xml/auto_install_accessibility&quot; /&gt;</span><br><span class="line">&lt;/service&gt;</span><br></pre></td></tr></table></figure></li><li><p>按照service注册时 所配置的android:resource 创建auto_install_accessibility.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;accessibility-service xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:accessibilityEventTypes=&quot;typeAllMask&quot;</span><br><span class="line">    android:accessibilityFeedbackType=&quot;feedbackGeneric&quot;</span><br><span class="line">    android:accessibilityFlags=&quot;&quot;</span><br><span class="line">    android:canRetrieveWindowContent=&quot;true&quot;</span><br><span class="line">    android:description=&quot;@string/setting_auto_install_acc_des&quot;</span><br><span class="line">    android:notificationTimeout=&quot;100&quot;</span><br><span class="line">    android:packageNames=&quot;com.android.packageinstaller,com.lenovo.safecenter,com.lenovo.security,com.xiaomi.gamecenter&quot;&gt;</span><br><span class="line">&lt;/accessibility-service&gt;</span><br></pre></td></tr></table></figure></li><li><p>编写Service 继承AccessibilityService 实现模拟点击</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 免root自动装</span><br><span class="line">* Created by TAJ_C on 2015/9/9.</span><br><span class="line"> */</span><br><span class="line">@SuppressLint(&quot;NewApi&quot;)</span><br><span class="line">public class AutoInstallAccessibilityService extends AccessibilityService &#123;</span><br><span class="line"></span><br><span class="line">    private static HashMap&lt;String, Boolean&gt; autoInstallMap;</span><br><span class="line"></span><br><span class="line">    private static final String[] INSTALL = &#123;&quot;安装&quot;, &quot;install&quot;&#125;;</span><br><span class="line">    private static final String[] NEXT = &#123;&quot;下一步&quot;, &quot;next&quot;&#125;;</span><br><span class="line">    private static final String[] FINISH = &#123;&quot;完成&quot;, &quot;complete&quot;&#125;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onAccessibilityEvent(AccessibilityEvent event) &#123;</span><br><span class="line">        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (event == null || event.getSource() == null || getRootInActiveWindow() == null) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (event.getPackageName() == null ||</span><br><span class="line"></span><br><span class="line">                        (false == event.getPackageName().equals(&quot;com.android.packageinstaller&quot;) &amp;&amp;</span><br><span class="line">                                false == event.getPackageName().equals(&quot;com.google.android.packageinstaller&quot;) &amp;&amp;</span><br><span class="line">                                false == event.getPackageName().equals(&quot;com.lenovo.safecenter&quot;) &amp;&amp;</span><br><span class="line">                                false == event.getPackageName().equals(&quot;com.lenovo.security&quot;) &amp;&amp;</span><br><span class="line">                                false == event.getPackageName().equals(&quot;com.xiaomi.gamecenter&quot;) &amp;&amp;</span><br><span class="line">                                 false == event.getPackageName().equals(&quot;com.samsung.android.packageinstaller&quot;))) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                if (false == isAutoInstall(getRootInActiveWindow())) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                clickButtonByName(event.getSource(), INSTALL);</span><br><span class="line">                clickButtonByName(event.getSource(), NEXT);</span><br><span class="line">                clickButtonByName(getRootInActiveWindow(), FINISH);</span><br><span class="line"></span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                LogUtils.e(e.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    *  只针对于本应用下载的应用才进行 自动安装</span><br><span class="line">    */</span><br><span class="line">    private boolean isAutoInstall(AccessibilityNodeInfo nodeInfo) &#123;</span><br><span class="line">        int queryFilter = DownloadManager.STATUS_SUCCESSFUL</span><br><span class="line">                | DownloadManager.STATUS_EXTRA_UPGRADABLE</span><br><span class="line">                | DownloadManager.STATUS_EXTRA_INSTALLED;</span><br><span class="line"></span><br><span class="line">        List&lt;TaskInfo&gt; taskInfoList = DownloadHelper.getDownloadTasks(</span><br><span class="line">                AutoInstallAccessibilityService.this,</span><br><span class="line">                DownloadHelper.QUERY_TYPE_BY_STATUS,</span><br><span class="line">                queryFilter);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        if (autoInstallMap == null) &#123;</span><br><span class="line">            autoInstallMap = new HashMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (TaskInfo taskInfo : taskInfoList) &#123;</span><br><span class="line">            String appName = taskInfo.getAppLabel();</span><br><span class="line">            if (!TextUtils.isEmpty(appName) &amp;&amp; autoInstallMap != null &amp;&amp;</span><br><span class="line">                    !autoInstallMap.containsKey(appName)) &#123;</span><br><span class="line">                autoInstallMap.put(appName, true);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        for (String appName : autoInstallMap.keySet()) &#123;</span><br><span class="line">            if (!TextUtils.isEmpty(appName) &amp;&amp; nodeInfo != null) &#123;</span><br><span class="line">                List&lt;AccessibilityNodeInfo&gt; nodeInfos = nodeInfo.findAccessibilityNodeInfosByText(appName);</span><br><span class="line">                if (!ListUtils.isEmpty(nodeInfos)) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onInterrupt() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    *  模拟点击</span><br><span class="line">    */</span><br><span class="line">    private void clickButtonByName(AccessibilityNodeInfo accessibilityNodeInfo, String[] btnNames) &#123;</span><br><span class="line">        for (String btnName : btnNames) &#123;</span><br><span class="line">            List&lt;AccessibilityNodeInfo&gt; okNodes = accessibilityNodeInfo.findAccessibilityNodeInfosByText(btnName);</span><br><span class="line">            if (!ListUtils.isEmpty(okNodes)) &#123;</span><br><span class="line">                for (AccessibilityNodeInfo node : okNodes) &#123;</span><br><span class="line">                    CharSequence charSequence = node.getText();</span><br><span class="line">                    if (TextUtils.isEmpty(charSequence) || !charSequence.toString().equals(btnName)) &#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if ((node.getClassName().equals(&quot;android.widget.Button&quot;) ||</span><br><span class="line">                            node.getClassName().equals(&quot;android.widget.TextView&quot;)) &amp;&amp; node.isEnabled()) &#123;</span><br><span class="line">                        node.performAction(AccessibilityNodeInfo.ACTION_CLICK);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 检查是否开启服务</span><br><span class="line">    public static boolean isAccessibilitySettingsOn(Context context) &#123;</span><br><span class="line">        int accessibilityEnabled = 0;</span><br><span class="line">        final String service = context.getPackageName() + &quot;/&quot; + AutoInstallAccessibilityService.class.getName();</span><br><span class="line">        boolean accessibilityFound = false;</span><br><span class="line">        try &#123;</span><br><span class="line">            accessibilityEnabled = Settings.Secure.getInt(context.getApplicationContext().getContentResolver(), android.provider.Settings.Secure.ACCESSIBILITY_ENABLED);</span><br><span class="line">        &#125; catch (Settings.SettingNotFoundException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        TextUtils.SimpleStringSplitter mStringColonSplitter = new TextUtils.SimpleStringSplitter(&apos;:&apos;);</span><br><span class="line">        if (accessibilityEnabled == 1) &#123;</span><br><span class="line">            String settingValue = Settings.Secure.getString(context.getApplicationContext().getContentResolver(), Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES);</span><br><span class="line">            if (settingValue != null) &#123;</span><br><span class="line">                TextUtils.SimpleStringSplitter splitter = mStringColonSplitter;</span><br><span class="line">                splitter.setString(settingValue);</span><br><span class="line">                while (splitter.hasNext()) &#123;</span><br><span class="line">                    String accessabilityService = splitter.next();</span><br><span class="line">                    if (accessabilityService.equalsIgnoreCase(service)) &#123;</span><br><span class="line">                        return true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Log.v(TAG, &quot;***ACCESSIBILIY IS DISABLED***&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return accessibilityFound;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onDestroy() &#123;</span><br><span class="line">        super.onDestroy();</span><br><span class="line">        if (autoInstallMap != null) &#123;</span><br><span class="line">            autoInstallMap.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>完结</p><p><a href="http://www.tuicool.com/articles/bYRZJn" target="_blank" rel="noopener">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;利用AccessibilityService实现免Root自动安装&quot;&gt;&lt;a href=&quot;#利用AccessibilityService实现免Root自动安装&quot; class=&quot;headerlink&quot; title=&quot;利用AccessibilityService实现免R
      
    
    </summary>
    
      <category term="Android" scheme="http://zaijiangwangzhuan.com/categories/Android/"/>
    
    
      <category term="黑科技" scheme="http://zaijiangwangzhuan.com/tags/%E9%BB%91%E7%A7%91%E6%8A%80/"/>
    
  </entry>
  
  <entry>
    <title>AndroidROM开发笔记</title>
    <link href="http://zaijiangwangzhuan.com/2014/01/05/2014-01-05-AndroidROM%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    <id>http://zaijiangwangzhuan.com/2014/01/05/2014-01-05-AndroidROM开发笔记/</id>
    <published>2014-01-05T08:46:00.000Z</published>
    <updated>2018-07-21T03:13:52.461Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网站备份"><a href="#网站备份" class="headerlink" title="网站备份"></a>网站备份</h2><h3 id="Android-ROM开源的网站"><a href="#Android-ROM开源的网站" class="headerlink" title="Android ROM开源的网站:"></a>Android ROM开源的网站:</h3><ul><li><a href="https://github.com/MiCode" target="_blank" rel="noopener">小米</a></li><li><a href="https://github.com/CyanogenMod/" target="_blank" rel="noopener">CM</a></li><li><a href="https://github.com/ShenduOS" target="_blank" rel="noopener">深度</a></li><li><a href="https://developers.google.com/android/nexus/drivers" target="_blank" rel="noopener">驱动下载</a></li><li><a href="http://goo.im/gapps" target="_blank" rel="noopener">android google服务包</a></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="如何修改系统默认字体大小"><a href="#如何修改系统默认字体大小" class="headerlink" title="如何修改系统默认字体大小"></a>如何修改系统默认字体大小</h3><p>修改这个默认值，可以在下面这个文件中进行修改<br>在alps/frameworks/base/core/java/android/content/res/Configuration.java文件中如下<br>public void setToDefaults() 这个方法中进行修改<br>如果默认要改成特大字体，请改为1.15f，然后重新build framework.jar这个模块即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void setToDefaults() &#123;</span><br><span class="line">       fontScale = 1.15f; //normal value is 1</span><br><span class="line">       mcc = mnc = 0;</span><br><span class="line"></span><br><span class="line">       注意：Settings中系统的字体大小，在/packages/apps/Settings/res/values/arrays.xml文件中的”entryvalues_font_size”这个tag中分别有定义对应的数值</span><br><span class="line">       Small:0.9</span><br><span class="line">        Normal:1.0</span><br><span class="line">        Large:1.1</span><br><span class="line">        Extra Large:1.15</span><br></pre></td></tr></table></figure></p><p>所以如果要修改默认值，直接在上面那个方法中修改fontScale 为对应的数值即可(注意带上f，表示为float类型)</p><h3 id="so库缺失拷贝到相应目录"><a href="#so库缺失拷贝到相应目录" class="headerlink" title="so库缺失拷贝到相应目录"></a>so库缺失拷贝到相应目录</h3><ul><li><p>拷贝SO文件示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PRODUCT_COPY_FILES += \</span><br><span class="line">vendor/cos/prebuilt/common/google/optional/face/lib/libfacelock_jni.so:system/lib/libfacelock_jni.so</span><br></pre></td></tr></table></figure></li><li><p>拷贝文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">google_system_lib_files := $(shell ls vendor/cos/prebuilt/common/google/system/lib )</span><br><span class="line">PRODUCT_COPY_FILES += $(foreach file, $(google_system_lib_files), \</span><br><span class="line">    vendor/cos/prebuilt/common/google/system/lib/$(file):system/lib/$(file))</span><br><span class="line"></span><br><span class="line">google_option_face_vendor_files := $(shell find vendor/cos/prebuilt/common/google/optional/face/vendor -name *.bin | sed &apos;s/vendor\/cos\/prebuilt\/common\/google\/optional\/face\/vendor/vendor/&apos; )</span><br><span class="line">PRODUCT_COPY_FILES += $(foreach file, $(google_option_face_vendor_files), \</span><br><span class="line">    vendor/cos/prebuilt/common/google/optional/face/$(file):system/$(file))</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;网站备份&quot;&gt;&lt;a href=&quot;#网站备份&quot; class=&quot;headerlink&quot; title=&quot;网站备份&quot;&gt;&lt;/a&gt;网站备份&lt;/h2&gt;&lt;h3 id=&quot;Android-ROM开源的网站&quot;&gt;&lt;a href=&quot;#Android-ROM开源的网站&quot; class=&quot;head
      
    
    </summary>
    
      <category term="Android" scheme="http://zaijiangwangzhuan.com/categories/Android/"/>
    
    
      <category term="ROM" scheme="http://zaijiangwangzhuan.com/tags/ROM/"/>
    
  </entry>
  
  <entry>
    <title>Android源码打包</title>
    <link href="http://zaijiangwangzhuan.com/2013/12/18/2013-12-18-Android%E6%BA%90%E7%A0%81%E6%89%93%E5%8C%85/"/>
    <id>http://zaijiangwangzhuan.com/2013/12/18/2013-12-18-Android源码打包/</id>
    <published>2013-12-18T08:46:00.000Z</published>
    <updated>2018-07-21T03:13:52.460Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Android源码打包"><a href="#Android源码打包" class="headerlink" title="Android源码打包"></a>Android源码打包</h2><h3 id="window-xp-系统"><a href="#window-xp-系统" class="headerlink" title="window xp 系统"></a>window xp 系统</h3><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><ol><li>搭建java 环境、</li><li>下载签名工具：Auto-sign</li><li>下载压缩工具：7zip<h4 id="拆包"><a href="#拆包" class="headerlink" title="拆包"></a>拆包</h4>在该文档“编辑源码”那块已经说明使用“make -jn otapackage”<br>该编译命令生成更加通用的zip格式的 ROM包。<br>拆包很简单，直接解压就行。</li></ol><h4 id="更改"><a href="#更改" class="headerlink" title="更改"></a>更改</h4><p> 下面是解压后文件夹内容：</p><ul><li>boot.img文件，这是系统的镜像，包括Linux内核以及系统启动的一些基本文件。<br>META-INF目录，这里主要有系统更新脚本，路径是：META-INF/com/google/android/updater-script</li><li>system/app目录，系统自带的应用程序都放在这个目录下，比如日历、联系人、gmail等，你可以把自己的apk文件放在该目录下，这样就可以在刷ROM的时候直接安装上</li><li>system/bin目录，系统命令，可以通过adb shell登录后执行，比如top</li><li>system/etc目录，类似linux的/etc目录</li><li>system/font目录，字体</li><li>system/framework目录，android框架，是java实现，在dalvik虚拟机下支持用户java开发的框架</li><li>system/lib目录，android本地共享库，都是so文件，是c、c++编译的本地共享库</li><li>system/media目录，一些媒体文件，比如bootanimation.zip，压缩包里面是一些png图，用于开机动画，替代这些可以改变开机画面，audio目录下是一些声音文件，用于铃声和通知等</li></ul><h4 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h4><p>  在META-INF 相同路径下，选中全部内容后右击用7zip打包该目录成为一个zip文件，并改名为update.zip</p><h4 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h4><p>  将完成的update.zip 放入Auto-sign的目录中，运行Sign.bat 在根目录就会自动生存update_signed.zip。如果不签名android是不认的，recovery的时候会在校验ROM包的时候报错。</p><h4 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h4><p>将update_signed.zip copy 至sdcard 根目录下，进入recovery 模式，选择update_signed.zip 升级即可。</p><h3 id="Linux-系统"><a href="#Linux-系统" class="headerlink" title="Linux  系统"></a>Linux  系统</h3><h4 id="准备-1"><a href="#准备-1" class="headerlink" title="准备"></a>准备</h4><ol><li>搭建java 环境、</li><li>签名工具：需要signapk.jar testkey.x509.pem testkey.pk8三个文件。<br>  三个文件是由Android整个源代码编译完后会自动生成,路径如下:</li></ol><ul><li>signapk.jar位于./out/host/linux-x86/framework/目录</li><li>testkey.x509.pem，testkey.pk8位于./build/target/product/security/目录</li></ul><h4 id="更改-1"><a href="#更改-1" class="headerlink" title="更改"></a>更改</h4><p>   同window xp系统下的更改。</p><h4 id="打包-1"><a href="#打包-1" class="headerlink" title="打包"></a>打包</h4><p>   在META-INF 相同路径下输入linux 指令<br>        zip -r update.zip ./*</p><h4 id="签名-1"><a href="#签名-1" class="headerlink" title="签名"></a>签名</h4><p>  将签名工具所需3个文件copy到与update.zip 同一路径下，在linux下执行签名指令，生成update_sign.zip 文件包，此即为升级包。<br>签名指令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar signapk.jar -w testkey.x509.pem testkey.pk8 update.zip update_sign.zip</span><br></pre></td></tr></table></figure></p><h4 id="升级-1"><a href="#升级-1" class="headerlink" title="升级"></a>升级</h4><p>将update_signed.zip copy 至sdcard 根目录下，进入recovery 模式，选择update_sign.zip 升级即可。</p><h3 id="增量更新包打包"><a href="#增量更新包打包" class="headerlink" title="增量更新包打包"></a>增量更新包打包</h3><p>步骤如下:</p><ol><li>建立2个文件夹目录：<br>mkdir ./META-INF/com/google/android/<br>mkdir ./system/app<br>注意：记得更改这2个目录及其子目录的权限，以免出现无法copy 文件的问题。</li><li>在android/目录下添加2个文件，分别是update-binary 和updater-script。</li></ol><ul><li>update-binary 在 /out/target/product/dkb/system/bin/ 目录下的updater 文件，直接将updater copy到 /META-INF/com/google/android/ ，并改名为update-binary 即可。</li><li>updater-script 脚本文件需要自己编写(具体脚本语法请参考相关文档)，根据具体升级的内容的不同，编写的脚本也是不一样的。下面贴出升级系统app的脚本。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ui_print(&quot;--------------------------------&quot;);</span><br><span class="line">ui_print(&quot;Mounting filesystem...&quot;);</span><br><span class="line">ui_print(&quot;--------------------------------&quot;);</span><br><span class="line"></span><br><span class="line">mount(&quot;ext4&quot;, &quot;EMMC&quot;, &quot;/dev/block/platform/msm_sdcc.1/by-name/system&quot;, &quot;/system&quot;);</span><br><span class="line">show_progress(0.1, 0);</span><br><span class="line">set_progress(1.000000);</span><br><span class="line">package_extract_dir(&quot;system/app&quot;,&quot;/system/app&quot;);</span><br><span class="line">show_progress(0.9, 5);</span><br><span class="line">ui_print(&quot;Updating System Finish....&quot;);</span><br><span class="line">unmount(&quot;/system&quot;);</span><br><span class="line"></span><br><span class="line">ui_print(&quot;--------------------------------&quot;);</span><br><span class="line">ui_print(&quot;         Update success!        &quot;);</span><br><span class="line">ui_print(&quot;--------------------------------&quot;);</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>将你需要升级的apk文件copy 到./system/app/ 目录中。</li><li>将META-INF 和 system 一起压缩成update.zip 包。  在META-INF 相同路径下输入linux 指令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ zip  -r  update.zip ./*</span><br></pre></td></tr></table></figure></li></ol><p>指令执行完成后，生成update.zip 压缩包</p><ol start="5"><li><p>将update.zip 签名。<br>同上一章节ROM 在linux下打包签名</p></li><li><p>将update_sign.zip copy 至sdcard 根目录下，进入recovery 模式，选择update_sign.zip 升级即可。</p></li></ol><h3 id="添加应用到Android-源码"><a href="#添加应用到Android-源码" class="headerlink" title="添加应用到Android 源码"></a>添加应用到Android 源码</h3><ol><li>在和系统相同版本的SDK目录下开发自己的android应用.</li><li>把开发的android工程放到源码的packages/apps/目录下</li><li>在自己应用工程目录下添加Android.mk文件<br>下面是用SnailMusic 为例, Android.mk内容如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_PATH:= $(call my-dir)</span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line">#表示目标模式</span><br><span class="line">LOCAL_MODULE_TAGS := optional</span><br><span class="line">#引用了两个第三方jar包，定义jar库的引用名，可以任意取值；</span><br><span class="line">LOCAL_STATIC_JAVA_LIBRARIES := libhttpclient\</span><br><span class="line">                               Androidsupport</span><br><span class="line"></span><br><span class="line"># Build all java files in the java subdirectory</span><br><span class="line">LOCAL_SRC_FILES := $(call all-java-files-under, src)</span><br><span class="line"></span><br><span class="line">LOCAL_SDK_VERSION := current</span><br><span class="line"># 生成apk的名字</span><br><span class="line">LOCAL_PACKAGE_NAME := SnailMusic</span><br><span class="line">#编译一个需要platform key签名的APK</span><br><span class="line">LOCAL_CERTIFICATE := platform</span><br><span class="line"></span><br><span class="line">＃所包含的库</span><br><span class="line">include $(BUILD_PACKAGE)</span><br><span class="line"></span><br><span class="line">######################################################</span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line"># 指定prebuiltjar库的规则，格式：引用名:jar文件路径</span><br><span class="line">LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES := libhttpclient:libs/commons-httpclient-3.1.jar\</span><br><span class="line">                                        androidsupport:libs/android-support-v4.jar</span><br><span class="line">LOCAL_MODULE_TAGS := optional</span><br><span class="line">include $(BUILD_MULTI_PREBUILT)</span><br><span class="line"></span><br><span class="line"># Use the folloing include to make our test apk.</span><br><span class="line">include $(call all-makefiles-under,$(LOCAL_PATH))</span><br></pre></td></tr></table></figure></li></ol><p>4 进入到&lt;android_src&gt;/build/target/product目录中，修改core.mk, sdk.mk文件，把自已的项目加入编译行列中。<br>5．最后进入到&lt;android_src&gt;源码根目录，全局编译</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Android源码打包&quot;&gt;&lt;a href=&quot;#Android源码打包&quot; class=&quot;headerlink&quot; title=&quot;Android源码打包&quot;&gt;&lt;/a&gt;Android源码打包&lt;/h2&gt;&lt;h3 id=&quot;window-xp-系统&quot;&gt;&lt;a href=&quot;#windo
      
    
    </summary>
    
      <category term="Android" scheme="http://zaijiangwangzhuan.com/categories/Android/"/>
    
    
      <category term="ROM" scheme="http://zaijiangwangzhuan.com/tags/ROM/"/>
    
  </entry>
  
  <entry>
    <title>Android源码编译与刷机</title>
    <link href="http://zaijiangwangzhuan.com/2013/12/16/2013-12-16-Android%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E4%B8%8E%E5%88%B7%E6%9C%BA/"/>
    <id>http://zaijiangwangzhuan.com/2013/12/16/2013-12-16-Android源码编译与刷机/</id>
    <published>2013-12-16T08:46:00.000Z</published>
    <updated>2018-07-21T03:13:52.459Z</updated>
    
    <content type="html"><![CDATA[<ul><li>content<br>{:toc}</li></ul><h2 id="源码编译"><a href="#源码编译" class="headerlink" title="源码编译"></a>源码编译</h2><h3 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h3><p><a href="source.android.com">source.android.com</a></p><h3 id="下载驱动"><a href="#下载驱动" class="headerlink" title="下载驱动"></a>下载驱动</h3><ol><li><a href="https://developers.google.com/android/nexus/drivers" target="_blank" rel="noopener">https://developers.google.com/android/nexus/drivers</a> 下载所需对应的机型的驱动二进制文件</li><li>将下载好的驱动文件解压到源码根目录下。</li><li>sh 文件名.sh 进行安装。</li></ol><h3 id="编译源码"><a href="#编译源码" class="headerlink" title="编译源码"></a>编译源码</h3><ol><li>设置编译环境：$ source build/envsetup.sh</li><li>选择编译对应的机型：$ lunch<br>代号对应的机型在下驱动文件时就能看到，例如 Nexus 4对应的代号就是mako，如果要编译该机型系统，选择11即可。</li><li>编译系统：</li></ol><ul><li>make –jn，n代表线程数，根据自己电脑的情况选择，一般双核CPU选择4个线程编译；该命令输出img格式的系统刷机文件。</li><li>make -jn otapackage该命令生成更加通用的zip格式，更加通用，比如第三方的recovery也能使用。</li></ul><ol start="4"><li>编译完成后，刷机文件一律生成于源码根目录/out/target/product/对应的设备代号</li></ol><h3 id="刷机"><a href="#刷机" class="headerlink" title="刷机"></a>刷机</h3><ol><li>编译fastboot和adb工具：<br>$ make fastboot adb</li><li>手机进入fastboot模式，一般是关机后，按住音量键减+电源键进入。</li><li>输入命令，查看设备是否被识别：./out/host/linux-x86/bin/fastboot devices</li><li>解锁设备：$ fastboot oem unlock</li><li>刷入ROM：</li></ol><ul><li>一次全部刷入，如下:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ fastboot flashall -w</span><br></pre></td></tr></table></figure></li></ul><p>一般情况下这一步会出现以下错误提示：neither -p product specified nor ANDROID_PRODUCT_OUT set；<br>原因是没有设置rom的位置，解决方法要么使用-p参数，后面跟着rom的位置；<br>或者配置环境变量ANDROID_PRODUCT_OUT，过程如下：<br>输入sudo gedit /etc/profile，在尾部添加export ANDROID_PRODUCT_OUT=源码目录/out/target/product/设备代号，保存并退出<br>然后输入source /etc/profile使刚设置的环境变量立即生效。</p><ul><li>单独刷boot,recovery,system三个img文件，如下:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ./fastboot flash bootloader /out/target/product/mako/boot.img</span><br><span class="line">$sudo ./fastboot reboot-bootloader</span><br><span class="line">$ sudo ./fastboot flash recovery out/target/product/mako/recovery.img</span><br><span class="line">$sudo ./fastboot reboot-bootloader</span><br><span class="line">$ sudo ./fastboot flash system -w out/target/product/mako/system.img</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;content&lt;br&gt;{:toc}&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;源码编译&quot;&gt;&lt;a href=&quot;#源码编译&quot; class=&quot;headerlink&quot; title=&quot;源码编译&quot;&gt;&lt;/a&gt;源码编译&lt;/h2&gt;&lt;h3 id=&quot;下载源码&quot;&gt;&lt;a href=&quot;#下载源
      
    
    </summary>
    
      <category term="Android" scheme="http://zaijiangwangzhuan.com/categories/Android/"/>
    
    
      <category term="ROM" scheme="http://zaijiangwangzhuan.com/tags/ROM/"/>
    
  </entry>
  
</feed>
